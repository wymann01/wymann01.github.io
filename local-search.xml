<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【翻译】Supporting Gesture Interaction in Your Apps在 App 中支持手势互动</title>
    <link href="/2023/09/04/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Supporting%20Gesture%20Interaction%20in%20Your%20Apps%E5%9C%A8%20App%20%E4%B8%AD%E6%94%AF%E6%8C%81%E6%89%8B%E5%8A%BF%E4%BA%92%E5%8A%A8/"/>
    <url>/2023/09/04/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Supporting%20Gesture%20Interaction%20in%20Your%20Apps%E5%9C%A8%20App%20%E4%B8%AD%E6%94%AF%E6%8C%81%E6%89%8B%E5%8A%BF%E4%BA%92%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>手势互动是iOS 平台最直观的用户体验之一，以及Gesture Recognizer提供了简单的方法去实现它。iOS 定义了一些<a href="https://developer.apple.com/design/human-interface-guidelines/ios/user-interaction/gestures/">标准手势</a>，同时提供了对应的Gesture Recognizer。你也可以自定义Gesture Recognizer来处理非标准的手势。本文的代码示例工程叫 pieces（片），用标准的Gesture Recognizer，为三个彩色 View 添加平移、缩放和旋转支持，以及如何实现一个自定义的Gesture Recognizer，将 pieces重置为初始状态。</p><h1 id="设置一个Gesture-Recognizer"><a href="#设置一个Gesture-Recognizer" class="headerlink" title="设置一个Gesture Recognizer"></a><strong>设置一个Gesture Recognizer</strong></h1><p>创建一个Gesture Recognizer，调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622496-addgesturerecognizer?language=objc"><code>addGestureRecognizer:</code></a>添加到view 上</p><div class="code-wrapper"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> resetGestureRecognizer <span class="hljs-operator">=</span> <span class="hljs-type">ResetGestureRecognizer</span>(target: <span class="hljs-keyword">self</span>, action: <span class="hljs-keyword">#selector</span>(resetPieces(<span class="hljs-keyword">_</span>:)))view.addGestureRecognizer(resetGestureRecognizer)</code></pre></div><p>Xcode中有UIKit 的标准Gesture Recognizer，开发者可以在storyboard中使用它们。在storyboard使用Gesture Recognizer：</p><ol><li>打开storyboard</li><li>在 Xcode的 Object Library 中找到Gesture Recognizer</li><li>拖到 View 上</li></ol><blockquote><p>这么简单也要说？</p></blockquote><p>就这样，Xcode自动地把Gesture Recognizer添加到storyboard上，同时把它跟 view 联系起来。像给其他 UI 元素添加 action一样，给Gesture Recognizer用同样方法进行添加。</p><h1 id="处理平移、捏合和旋转手势"><a href="#处理平移、捏合和旋转手势" class="headerlink" title="处理平移、捏合和旋转手势"></a><strong>处理平移、捏合和旋转手势</strong></h1><p>本示例代码用平移 pan、捏合pinch 和旋转手势，来移动、缩放和旋转视图。当用户平移一个 View 时，UIKit 触发相关action 函数，在本示例代码中为panPiece(<em>:)。传入一个带有偏移量（translation）的<a href="https://developer.apple.com/documentation/uikit/uipangesturerecognizer?language=objc"><code>UIPanGestureRecognizer</code></a>示例。panPiece(</em>:)会计算和移动 view 到新的位置，然后将偏移量清零，下次偏移量的值就完全是相对新位置的增量。</p><div class="code-wrapper"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> translation <span class="hljs-operator">=</span> panGestureRecognizer.translation(in: piece.superview)piece.center <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: piece.center.x <span class="hljs-operator">+</span> translation.x, y: piece.center.y <span class="hljs-operator">+</span> translation.y)panGestureRecognizer.setTranslation(.zero, in: piece.superview)</code></pre></div><p>类似的，当用户捏合和旋转一个 View，本示例代码用UIPinchGestureRecognizer的scale 属性、UIRotationGestureRecognizer的rotation属性，来计算和应用新的变换，然后清零那些属性。</p><div class="code-wrapper"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> scale <span class="hljs-operator">=</span> pinchGestureRecognizer.scalepiece.transform <span class="hljs-operator">=</span> piece.transform.scaledBy(x: scale, y: scale)pinchGestureRecognizer.scale <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">// 清空 scale 属性，那么下次 scale 使用时就是正确的增量</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs Swift">piece.transform <span class="hljs-operator">=</span> piece.transform.rotated(by: rotationGestureRecognizer.rotation)rotationGestureRecognizer.rotation <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 清空 rotation 属性，下次 rotation 使用时就是正确的增量</span></code></pre></div><p>scale 和rotation属性跟这个 view.layer.<a href="https://developer.apple.com/documentation/quartzcore/calayer/1410817-anchorpoint?language=objc"><code>anchorPoint</code></a> 有关。</p><blockquote><p>anchorPoint：边界的锚点，view 的中心点，旋转就是围绕这个锚点进行。可以配置不同的锚点，锚点不同，旋转的效果不同。默认值是(0.5, 0.5) ，代表这个 view 的 layer 的矩形 bound 的中心。</p></blockquote><p>为了在缩放和旋转时更加直观，本示例将anchorPoint移动到手势的位置，而这通常是手势中包含的touch 的质心。</p><div class="code-wrapper"><pre><code class="hljs Swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">adjustAnchor</span>(<span class="hljs-params">for</span> <span class="hljs-params">gestureRecognizer</span>: <span class="hljs-type">UIGestureRecognizer</span>) &#123;    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> piece <span class="hljs-operator">=</span> gestureRecognizer.view, gestureRecognizer.state <span class="hljs-operator">==</span> .began <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">let</span> locationInPiece <span class="hljs-operator">=</span> gestureRecognizer.location(in: piece)    <span class="hljs-keyword">let</span> locationInSuperview <span class="hljs-operator">=</span> gestureRecognizer.location(in: piece.superview)    <span class="hljs-keyword">let</span> anchorX <span class="hljs-operator">=</span> locationInPiece.x <span class="hljs-operator">/</span> piece.bounds.size.width    <span class="hljs-keyword">let</span> anchorY <span class="hljs-operator">=</span> locationInPiece.y <span class="hljs-operator">/</span> piece.bounds.size.height    piece.layer.anchorPoint <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: anchorX, y: anchorY)    piece.center <span class="hljs-operator">=</span> locationInSuperview&#125;</code></pre></div><h1 id="允许同时识别多个手势"><a href="#允许同时识别多个手势" class="headerlink" title="允许同时识别多个手势"></a><strong>允许同时识别多个手势</strong></h1><p>用户有时候想多个手势同时工作，比如同时捏合和旋转。本示例通过实现<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerdelegate?language=objc"><code>UIGestureRecognizerDelegate</code></a>中方法允许了这种效果，也就是在shouldRecognizeSimultaneouslyWith 函数中返回 Yes，允许同时操作。</p><div class="code-wrapper"><pre><code class="hljs Swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">gestureRecognizer</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">gestureRecognizer</span>: <span class="hljs-type">UIGestureRecognizer</span>,                       <span class="hljs-params">shouldRecognizeSimultaneouslyWith</span> <span class="hljs-params">otherGestureRecognizer</span>: <span class="hljs-type">UIGestureRecognizer</span>) -&gt; <span class="hljs-type">Bool</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div><p>为了让 delegate 方法生效，本示例将Gesture Recognizer的 delegate 置为self，也就是实现方法的view controller</p><div class="code-wrapper"><pre><code class="hljs Swift">resetGestureRecognizer.delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span></code></pre></div><p>对于在storyboard中的Gesture Recognizer，通过拖拽来设置它们的delegate。</p><p>UIGestureRecognizerDelegate 提供了控制「手势识别」顺序的方法，想了解更多有关手势识别顺序的，请看「优先考虑某个手势<a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/coordinating_multiple_gesture_recognizers/preferring_one_gesture_over_another?language=objc">Preferring one gesture over another</a>.」</p><h1 id="创建自定义的Gesture-Recognizer"><a href="#创建自定义的Gesture-Recognizer" class="headerlink" title="创建自定义的Gesture Recognizer"></a><strong>创建自定义的Gesture Recognizer</strong></h1><p>本示例创建了一个自定义的Gesture Recognizer—— <code>ResetGestureRecognizer</code>，识别的是包含至少三个水平转弯的手势。用户可以用它来初始化视图。怎么做呢？将view从初始位置上挪走，然后把一根手指放到没有彩色 view 覆盖的地方，左右来回划动，好像在屏幕上甩动你的手指。</p><blockquote><p>其实更形象的说法是手指在水平方向上折返跑。</p></blockquote><p>为了识别这个手势，本示例在<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer/1620009-touchesbegan"><code>touchesBegan(_:with:)</code></a>抓起合法的 touch，在<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer/1619996-touchesmoved"><code>touchesMoved(_:with:)</code></a>中收集 touch 的位置。当用户抬起手指，触发<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer/1620005-touchesended"><code>touchesEnded(_:with:)</code></a>，本示例开始数触摸路径上有多少次转弯，如果路径上有两个以上的转弯，将 state 设置为 .ended，识别出这个手势来。</p><div class="code-wrapper"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> count <span class="hljs-operator">=</span> countHorizontalTurning(touchedPoints: touchedPoints)state <span class="hljs-operator">=</span> count <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">?</span> .ended : .failed</code></pre></div><p>注意，本示例没有进一步消除位置误差或者检查它们的距离来验证，在真实世界里，这些措施是要考虑执行的，从而提高识别精确度和避免识别错误。</p><p>更多有关自定义Gesture Recognizer的细节，请读「实现一个自定义Gesture Recognizer <a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer">Implementing a custom gesture recognizer</a>. 」</p><blockquote><p>总结：介绍了如何允许多个手势同时工作，如何处理标准手势、以及如何通过自定义Gesture Recognizer处理非标准手势。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【翻译】About the Gesture Recognizer State Machine关于Gesture Recognizer 的状态机</title>
    <link href="/2023/09/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91About%20the%20Gesture%20Recognizer%20State%20Machine%E5%85%B3%E4%BA%8EGesture%20Recognizer%20%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <url>/2023/09/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91About%20the%20Gesture%20Recognizer%20State%20Machine%E5%85%B3%E4%BA%8EGesture%20Recognizer%20%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer/about_the_gesture_recognizer_state_machine?language=objc">https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer/about_the_gesture_recognizer_state_machine?language=objc</a></p><p>—-学习Gesture Recognizer底层的state 和 state 的转变。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Gesture Recognizer被状态机驱动（<strong>state machine</strong>），UIKit也用 ta 来保证正确处理事件。状态机决定了几个重要的行为：</p><ul><li>Gesture Recognizer是否被允许进入<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatebegan?language=objc"><code>UIGestureRecognizerStateBegan</code></a> 状态。</li><li>Gesture Recognizer是否被允许进入<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstateended?language=objc"><code>UIGestureRecognizerStateEnded</code></a>状态。（这个是 end，上面的是 began）</li><li>什么时候调用action 函数？</li></ul><p>自定义一个 Gesture Recognizer 时，你必须在合适的时候更新状态机。一个 Gesture Recognizer 永远都是从<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatepossible?language=objc"><code>UIGestureRecognizerStatePossible</code></a>开始，表示 ta已经准备好可以处理事件了。分离的和连续的 Gesture Recognizer 会经过不同的路径到达<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstateended?language=objc"><code>UIGestureRecognizerStateEnded</code></a>, <a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatefailed?language=objc"><code>UIGestureRecognizerStateFailed</code></a>, 或者<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatecancelled?language=objc"><code>UIGestureRecognizerStateCancelled</code></a> 状态，Gesture Recognizer 会待在这几个状态之一，知道事件序列结束。</p><p>最后，UIKit 会重置Gesture Recognizer ，并让它回到<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatepossible?language=objc"><code>UIGestureRecognizerStatePossible</code></a>状态。</p><h1 id="分离的Gesture-Recognizer-的状态转变"><a href="#分离的Gesture-Recognizer-的状态转变" class="headerlink" title="分离的Gesture Recognizer 的状态转变"></a><strong>分离的Gesture Recognizer 的状态转变</strong></h1><p>对于自定义的、分离的Gesture Recognizer ，ta 有两种状态<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstateended?language=objc"><code>UIGestureRecognizerStateEnded</code></a> 或 <a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatefailed?language=objc"><code>UIGestureRecognizerStateFailed</code></a>。下图展示了它的转变路径。当不断到来的事件匹配到了你写的手势，识别器会转到<code>UIGestureRecognizerStateEnded</code>，当匹配失败时，转到<code>UIGestureRecognizerStateFailed</code>。</p><p><img src="https://secure2.wostatic.cn/static/5EGB4JaPaWFc7LK2g9xT3d/image.png?auth_key=1693715005-fAcm71zDWMHZehaSz6iX9j-0-5977b7bfcc3b495a98d185e181d2892c"></p><blockquote><p>图文似乎有点不符，右侧圆圈内应为「Ended」。</p></blockquote><p>当转到结束的状态时（<code>UIGestureRecognizerStateEnded</code>），UIKit会调用所有关联目标对象的 action 函数。</p><p>如果转到的是失败的状态（<code>UIGestureRecognizerStateFailed</code>），不调用任何函数。</p><p>想了解实际例子的，请看<a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer/implementing_a_discrete_gesture_recognizer?language=objc">「实现一个分离的Gesture Recognizer</a>」 。</p><p><strong>连续的的Gesture Recognizer 的状态转变</strong></p><p>先看图</p><p><img src="https://secure2.wostatic.cn/static/xxxm1dG58kaEb4bK7qePmr/image.png?auth_key=1693715005-qoz8EvKnTY2G6cJ6ZJX7E4-0-0b20b66d4721d9c2b37529605dcd9a68"></p><ul><li>初始的事件序列会将Gesture Recognizer 转到</li></ul><p><a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatebegan?language=objc"><code>UIGestureRecognizerStateBegan</code></a> 或 <a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatefailed?language=objc"><code>UIGestureRecognizerStateFailed</code></a>状态</p><ul><li>接下来的事件序列会让 ta 转到<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatechanged?language=objc"><code>UIGestureRecognizerStateChanged</code></a> 或 <a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatecancelled?language=objc"><code>UIGestureRecognizerStateCancelled</code></a></li><li>最后是<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstateended?language=objc"><code>UIGestureRecognizerStateEnded</code></a></li></ul><p>如果初始事件序列不能匹配上你写的手势，那Gesture Recognizer 会直接从 possible 到 failed。正常情况下，UIKit 一次只允许一个Gesture Recognizer 通知 client（也就是在定义时写好的 target）。一个Gesture Recognizer 失败了，就会给其他Gesture Recognizer 一次处理它们手势的机会。</p><p>如果初始事件序列匹配上了你的手势，Gesture Recognizer会转到<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatebegan?language=objc"><code>UIGestureRecognizerStateBegan</code></a>状态，对于后续的事件，会重复地转到<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatechanged?language=objc"><code>UIGestureRecognizerStateChanged</code></a>状态，表示事件信息已经改变（即便 state 已经是 changed 的取值了，也要不断地设置 state 状态，因为「设置 state」这个动作会触发对应的 action 函数）。最后，就是成功识别就把 state 置为ended ，失败就置为cancelled。当Gesture Recognizer的state 被置为began、changed和ended 三者之一时，UIKit都会调用 action 函数。否则，不调用任何函数。</p><p>要了解实际例子，看「<a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer/implementing_a_continuous_gesture_recognizer?language=objc">实现一个连续的Gesture Recognizer</a>」</p><h1 id="处理「取消操作」"><a href="#处理「取消操作」" class="headerlink" title="处理「取消操作」"></a><strong>处理「取消操作」</strong></h1><p>当「系统事件」中断了「事件序列」时（比如有电话打进来）手势取消就发生了。也可以事件序列中的信息或者App 中的其他条件，用代码取消手势。「取消」会防止Gesture Recognizer执行某些用户并不想做的操作。</p><p>当系统取消手势时，UIKit 会调用<a href="https://developer.apple.com/documentation/uikit/uiresponder/1621116-touchescancelled?language=objc"><code>touchesCancelled:withEvent:</code></a> ， <a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer/1619999-pressescancelled?language=objc"><code>pressesCancelled:withEvent:</code></a>。同时，马上把Gesture Recognizer的 state 置为 cancelled，UIKit 会调用 action函数最后一次。随即重置（见下）。</p><h1 id="重置Gesture-Recognizer-的状态机"><a href="#重置Gesture-Recognizer-的状态机" class="headerlink" title="重置Gesture Recognizer 的状态机"></a><strong>重置Gesture Recognizer 的状态机</strong></h1><p>实现<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer/1620004-reset?language=objc"><code>reset</code></a>方法，让你的Gesture Recognizer回到初始配置。例如，用这个方法来把识别器的属性置为初始值，在处理新的事件序列前，UIkit 会调用符合以下条件的Gesture Recognizer的<code>reset</code> 函数：</p><ol><li>接收touch 事件的</li><li>处在failed、ended 和cancelled 状态的</li></ol><p>除了调用 <code>reset</code> 函数，UIKit 会自动修改每一个UIGestureRecognizerStateFailed 的 state 为possible 状态，以便它们能响应新的事件序列。</p><blockquote><p>总结：不同类型的Gesture Recognizer的状态机转变路径是不一样的；手势取消也会调用 一次action 函数；处理新的事件序列前可以重置一下Gesture Recognizer。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【翻译】Implementing a custom gesture recognizer实现自定义的手势识别器</title>
    <link href="/2023/09/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Implementing%20a%20custom%20gesture%20recognizer%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/"/>
    <url>/2023/09/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Implementing%20a%20custom%20gesture%20recognizer%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>——探索「什么时候」以及如何打造自定义的 Gesture Recognizer 。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>当 UIKi 内置的 Gesture Recognizer 不能满足需求时，你就可以自定义一个。UIKit包含了高度可配置的 Gesture Recognizer ，可以处理轻击tap、长按long press、拖动pan、滑动 swipe、旋转rotation和捏合pinch的 touch 序列。</p><p>对于其他的 touch 序列，或者处理涉及按下按钮的手势，你可以自定义一个 Gesture Recognizer </p><blockquote><p>译者注：touch序列（touch sequence），指的是一个或多个 UITouch对象，它们最终会组成一个 UIEvent 对象。</p></blockquote><p>也可以用自定义的Gesture Recognizer 来简化事件处理。例如，<a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/leveraging_touch_input_for_drawing_apps?language=objc">Leveraging Touch Input for Drawing Apps</a>这个示例代码就是用自定义的Gesture Recognizer，来捕获input并把它展示到屏幕上，如图：</p><p><img src="https://secure2.wostatic.cn/static/h3VbWKZEqgDDPpBsPj7Bqf/image.png?auth_key=1693714189-w5kVniVo2d9tLm3SsTd49h-0-263a178fa8800190d890b282077f380c"></p><p>想要自定义Gesture Recognizer，需要先继承它。记得在你的代码文件开头导入对应头文件（OC：UIGestureRecognizerSubclass.h； Swift：UIKit.UIGestureRecognizerSubclass）。这些头文件定义了你必须重写的方法：</p><div class="code-wrapper"><pre><code class="hljs Objective-C">#import &lt;UIKit/UIKit.h&gt;#import &quot;UIGestureRecognizerSubclass.h&quot;</code></pre></div><p>在你的子类中，实现那些处理事件的方法。例如，如果你要处理的手势由touch 事件组成，那就实现<a href="https://developer.apple.com/documentation/uikit/uiresponder/1621142-touchesbegan?language=objc"><code>touchesBegan:withEvent:</code></a>, <a href="https://developer.apple.com/documentation/uikit/uiresponder/1621107-touchesmoved?language=objc"><code>touchesMoved:withEvent:</code></a>, <a href="https://developer.apple.com/documentation/uikit/uiresponder/1621084-touchesended?language=objc"><code>touchesEnded:withEvent:</code></a>, 和 <a href="https://developer.apple.com/documentation/uikit/uiresponder/1621116-touchescancelled?language=objc"><code>touchesCancelled:withEvent:</code></a> 方法。用不断到来的事件更新你子类的<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer/1619998-state?language=objc"><code>state</code></a>属性。</p><p>UIKit会用这个 state 来协调互动你 App 里的其他对象。</p><blockquote><p>总结：什么时候该自定义一个Gesture Recognizer？当你觉得现有的不够用时；如何自定义？导入头文件，实现事件处理方法。（老实说我觉得这文章有点水）</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【翻译】Handling UIKit gestures 处理 UIkit 的 gesture</title>
    <link href="/2023/09/03/%5B%E7%BF%BB%E8%AF%91%5DHandling%20UIKit%20gestures%20%E5%A4%84%E7%90%86%20UIkit%20%E7%9A%84%20gesture/"/>
    <url>/2023/09/03/%5B%E7%BF%BB%E8%AF%91%5DHandling%20UIKit%20gestures%20%E5%A4%84%E7%90%86%20UIkit%20%E7%9A%84%20gesture/</url>
    
    <content type="html"><![CDATA[<p>——使用Gesture  Recognizer来简化Touch处理和打造统一的用户体验</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Gesture  Recognizer是处理点击和长按事件的最简单方法，你可以把一个或者几个Gesture  Recognizer附加到任何view上，它封装了处理和解释事件的所有逻辑，并把它们匹配到已知的模式。当检测到匹配，Gesture  Recognizer会通知特定对象，这个对象可以是view controller, view  本身，或者App中的其他对象。</p><p>Gesture  Recognizer用 target-action模式来发送通知。当一个 </p><p><a href="https://developer.apple.com/documentation/uikit/uitapgesturerecognizer?language=objc"><code>UITapGestureRecognizer</code></a>对象检测到view中的单指点击时，它会调用这个 view 的 view controller 里的action 函数。</p><blockquote><p>译者注：这里的 action 函数指在Gesture  Recognizer 在创建时就定义好的、一旦触发就去调用的方法。下同。</p></blockquote><p><img src="https://secure2.wostatic.cn/static/x28vNKMSHe1uCEhoLp7jKF/image.png?auth_key=1693713746-wzAt9jYJhQBVMuQ56nASG1-0-0f4161c6ddfe64e69749b1a48aa44b1d"></p><h1 id="Gesture-recognizer-有两种：离散的和连续的"><a href="#Gesture-recognizer-有两种：离散的和连续的" class="headerlink" title="Gesture recognizer 有两种：离散的和连续的"></a>Gesture recognizer 有两种：<strong>离散</strong>的和<strong>连续</strong>的</h1><p>离散的Gesture recognizer在检测到手势后仅仅调用一次action 函数。</p><p>而对于连续的Gesture  Recognize，在（手势）满足识别标准后，它会调用 action 方法很多次，只要手势事件里的信息有改变就会通知你。比如，一个<a href="https://developer.apple.com/documentation/uikit/uipangesturerecognizer?language=objc"><code>UIPanGestureRecognizer</code></a>对象会在每一次「触碰位置」改变时调用action 函数。</p><p>Interface Builder 包含每一种标准的 UIKit Gesture  Recognizer对象，它还包含了自定义的Gesture  Recognizer，你可以用这个来代表你自己的Gesture  Recognizer子类</p><blockquote><p>后半句我也没看懂，原文如下：<br>It also includes a custom gesture recognizer object that you can use to represent your custom <a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer?language=objc"><code>UIGestureRecognizer</code></a> subclasses.</p></blockquote><h1 id="配置一个Gesture-Recognizer"><a href="#配置一个Gesture-Recognizer" class="headerlink" title="配置一个Gesture  Recognizer"></a><strong>配置一个Gesture  Recognizer</strong></h1><p>步骤：</p><ol><li>在storyboard中，拖一个Gesture  Recognizer到你的 VIew 上</li><li>实现对应的 action 函数。查看接下来的代码</li><li>将你的 action函数连到那个Gesture  Recognizer</li></ol><p>你可以在Interface Builder创建这个连接，只需要右击Gesture  Recognizer和连接它的Sent Action selector 到你接口中的合适对象。你也可以用纯代码的方式——<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer/1624230-addtarget?language=objc"><code>addTarget:action:</code></a>。</p><p>以下代码展示了一个Gesture  Recognizer的 action 函数，它的一般形式：</p><div class="code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-keyword">IBAction</span>)myActionMethod:(<span class="hljs-built_in">UIGestureRecognizer</span>*)sender</code></pre></div><h1 id="响应手势"><a href="#响应手势" class="headerlink" title="响应手势"></a><strong>响应手势</strong></h1><p>action 函数提供了你的 App 对手势的反应。对于离散的Gesture  Recognizer，你的 action 函数会跟 UIButton的 action 函数差不多。一旦 action 函数执行，你就执行合理的任务。</p><p>而对于连续的Gesture  Recognizer，你的 action 函数可以响应手势识别后，也可以在识别成功前跟踪事件。跟踪事件能够创造更有互动性的体验。例如，你可以<a href="https://developer.apple.com/documentation/uikit/uipangesturerecognizer?language=objc"><code>UIPanGestureRecognizer</code></a>对象里的「信息更新」来移动你App 里的内容。</p><p>Gesture  Recognizer的<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer/1619998-state?language=objc"><code>state</code></a>属性，能告诉我们对象<strong>当前的识别状态</strong>。连续的Gesture  Recognizer的 state 属性，取值范围是<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatebegan?language=objc"><code>UIGestureRecognizerStateBegan</code></a> （开始）、 <a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatechanged?language=objc"><code>UIGestureRecognizerStateChanged</code></a> （改变）、 <a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstateended?language=objc"><code>UIGestureRecognizerStateEnded</code></a>（结束），还有 <a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerstate/uigesturerecognizerstatecancelled?language=objc"><code>UIGestureRecognizerStateCancelled</code></a>.（取消）。你可以在 action 函数里根据这个 state 来做操作。举个例子，你可以用「开始」「改变」两个state 来对内容做一些临时的改变，用「结束」state 来使「改变」成效。</p><p>在进行任何操作之前，永远都要先检查 state 的值。</p><hr><p>如何处理特定的手势，以下链接给出了一些例子：</p><ul><li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures/handling_tap_gestures?language=objc">Handling tap gestures</a>点击</li><li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures/handling_long-press_gestures?language=objc">Handling long-press gestures</a>长按</li><li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures/handling_pan_gestures?language=objc">Handling pan gestures</a>平移（各个方向）</li><li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures/handling_swipe_gestures?language=objc">Handling swipe gestures</a>滑动（单个方向）</li><li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures/handling_pinch_gestures?language=objc">Handling pinch gestures</a>捏合</li><li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures/handling_rotation_gestures?language=objc">Handling rotation gestures</a>旋转</li></ul><p>如果要了解更多有关 Gesture  Recognizer state相关信息以及它们如何影响你的代码，请看<a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer?language=objc">实现一个自定义的手势识别器</a>。</p><blockquote><p>总结：本文介绍了 Gesture Recognizer 的工作模式、有哪两种 Gesture Recognizer 、 如何配置Gesture Recognizer 以及 Gesture Recognizer 的 state 属性。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为了研究手势识别器，我一口气翻译了四篇文档</title>
    <link href="/2023/09/03/GestureRecognizer/"/>
    <url>/2023/09/03/GestureRecognizer/</url>
    
    <content type="html"><![CDATA[<ol><li><p>Handling UIKit gestures 处理 UIKit 的手势</p><p> 引出 Gesture Recognizer，介绍了 ta 有哪些类型，以及怎么配置一个 Gesture Recognizer。文章不长。</p></li><li><p>Implementing a custom gesture recognizer 实现自定义的 Gesture Recognizer</p><p> 给出了一个自定义 Gesture Recognizer的 demo，同时也说了如果要自定义的话需要实现哪些方法。</p></li><li><p><strong>About the Gesture Recognizer State Machine 关于手势识别器的状态机</strong></p><p> 介绍了 Gesture Recognizer的 state 属性。不同类型的 Gesture Recognizer怎么使用 state 属性，如何取消手势识别，以及最终如何重置 Gesture Recognizer。都是围绕 state 的变化讨论的，推荐。</p></li><li><p><strong>Supporting Gesture Interaction in Your Apps 在 App 中支持手势互动</strong></p><p> 用一个示例工程 pieces，介绍了如何处理平移、捏合和旋转手势，以及怎么让手势同时工作，最后是介绍了如何自定义一个 Gesture Recognizer处理非标准的手势</p></li></ol><p>苹果的文档不得不说是有点啰嗦和繁琐的，有时候一个意思翻过来倒过去讲两三遍，直接看英文的话就很容易就看走神了，于是我就想着把它翻译过来，正视 ta。</p><p>推荐是先看点中文的文章，对一些概念有了解了，然后再认真看第 3 第 4 篇文档，对  Gesture Recognizer就能有一个比较全面的印象。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UIPickerView 如何修改选中行的样式?</title>
    <link href="/2023/08/29/UIPickerView-%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E9%80%89%E4%B8%AD%E8%A1%8C%E7%9A%84%E6%A0%B7%E5%BC%8F/"/>
    <url>/2023/08/29/UIPickerView-%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E9%80%89%E4%B8%AD%E8%A1%8C%E7%9A%84%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="UIPickerView-如何修改选中行的样式"><a href="#UIPickerView-如何修改选中行的样式" class="headerlink" title="UIPickerView 如何修改选中行的样式"></a>UIPickerView 如何修改选中行的样式</h1><p><img src="/../image/UIPickerView/UIPickerView.png"></p><p>本文会介绍两个我在使用 UIPickerView 时遇到的问题, 最后给出它们的解决方法：</p><ol><li>如何<strong>无延迟</strong>地更新选中行的样式？</li><li>如何修改选中行的背景颜色？</li></ol><h2 id="选中行的样式"><a href="#选中行的样式" class="headerlink" title="选中行的样式"></a>选中行的样式</h2><p>需求中，要求更改选中行的字体颜色和字重，加粗+变色。我一开始尝试在「选中回调函数pickerView:didSelectRow:inComponent: 」 这个回调函数中，获取当前选中的 view，然后修改它的样式，但是这样的效果不够丝滑，需要松开手、有大约 0.5s 的延迟，才会看到选中效果</p><p><img src="/../image/UIPickerView/NotSelected.gif"></p><p>同时还有一个问题，就是在用户还没有开始滚动选择之初，当前选中行是没有「选中效果」的。哪怕手动调用</p><p>selectRow:inComponent:animated: 函数，pickerView也滑到了指定行，也不会触发pickerView:didSelectRow:inComponent: 这个回调。</p><blockquote><p>这个问题其实我还没研究清楚为啥，期待有知道的大佬指点一下迷津</p></blockquote><p>于是我去github 上看看有没有人解决了这个问题，找到了一个 star 数有2k+的<a href="https://github.com/91renb/BRPickerView" title="BRPickerView">BRPickerView</a>，人家的选中效果就很丝滑，翻了翻代码，发现ta 是在pickerView:viewForRow:forComponent:reusingView: 中设置当前选中行的样式，如下：</p><div class="code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-built_in">UIView</span> *)pickerView:(<span class="hljs-built_in">UIPickerView</span> *)pickerView viewForRow:(<span class="hljs-built_in">NSInteger</span>)row forComponent:(<span class="hljs-built_in">NSInteger</span>)component reusingView:(<span class="hljs-built_in">UIView</span> *)view &#123;    <span class="hljs-comment">// 设置选中行字体颜色和字体大小</span>    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;        <span class="hljs-built_in">UILabel</span> *label = (<span class="hljs-built_in">UILabel</span> *)[pickerView viewForRow:row forComponent:component];        label.textColor = <span class="hljs-built_in">UIColor</span>.blueColor;        [label setFont:[<span class="hljs-built_in">UIFont</span> systemFontOfSize:<span class="hljs-number">20</span> weight:<span class="hljs-number">20</span>]];    &#125;);  &#125;&#125;</code></pre></div><p>但是为什么要放在<strong>dispatch_after</strong> 里立即执行，这个暂时也不太清楚，我自己动手测试，不包这一层不影响效果，猜测是包了这一层后能够保证其中的代码能够立刻在主队列执行，同时避免发生子线程修改 UI而 crash的情况。</p><p>看了下<strong>pickerView:viewForRow:forComponent:reusingView:</strong> 的文档，</p><blockquote><p>Called by the picker view when it needs the view to use for a given row in a given component.<br>*当 pickerView 需要那个 view 用于指定列中的指定行时，它会调用该方法来获取。<br>*</p><p>我自己经过测试，初始化和滚动时都会调用这个回调，而且不止一次</p><p>初始化：#2    0x00000001144c2060 in -[UIPickerView tableView:cellForRowAtIndexPath:] ()。<strong>5</strong> 个元素的 pickerView 调用了 **8 <strong>次该函数<br>滑动：#1    0x0000000113e59060 in -[UIPickerView tableView:cellForRowAtIndexPath:] ()，调用</strong> 2 **次</p></blockquote><hr><p><strong>anyway，把修改样式的代码放到pickerView:viewForRow:forComponent:reusingView:后，不仅丝滑了很多，而且在初始、用户未滚动的时候也能保证有选中效果，成功实现需求。</strong></p><p><img src="/../image/UIPickerView/SelectedEffect.gif"></p><h2 id="修改选中行的背景颜色"><a href="#修改选中行的背景颜色" class="headerlink" title="修改选中行的背景颜色"></a>修改选中行的背景颜色</h2><p>还有一个常见的需求就是修改选中行的背景颜色，如上图，选中行的 View 我们可以通过 <strong>[pickerView viewForRow:row forComponent:component]</strong> 这样的代码获取，但是有问题, 如果给这个 View 设置背景颜色，前面会留有空隙，如图：</p><p><img src="/../image/UIPickerView/gap.png"></p><p>这办法还不行，得找到外部的容器，修改它的背景颜色才行。在 BRPickerView 中找到的方法如下：</p><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// 设置选中行背景色</span>    <span class="hljs-comment">// 1. 获取 pickerView 的子 View（有多个），取第一个 view，称之为 contentView</span>    <span class="hljs-built_in">UIView</span> *contentView = <span class="hljs-literal">nil</span>;    <span class="hljs-built_in">NSArray</span> *subviews = pickerView.subviews;    <span class="hljs-keyword">if</span> (subviews.count &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">id</span> firstObj = subviews.firstObject;        <span class="hljs-keyword">if</span> (firstObj &amp;&amp; [firstObj isKindOfClass:[<span class="hljs-built_in">UIView</span> <span class="hljs-keyword">class</span>]]) &#123;            contentView = (<span class="hljs-built_in">UIView</span> *)firstObj;        &#125;    &#125;        <span class="hljs-comment">// 2. 在 contentView 中通过 KVC 取它的 subviewCache 属性，称为 columnView</span>    <span class="hljs-built_in">UIView</span> *columnView = <span class="hljs-literal">nil</span>;    <span class="hljs-keyword">if</span> (contentView) &#123;        <span class="hljs-type">id</span> obj = [contentView valueForKey:<span class="hljs-string">@&quot;subviewCache&quot;</span>];        <span class="hljs-keyword">if</span> (obj &amp;&amp; [obj isKindOfClass:[<span class="hljs-built_in">NSArray</span> <span class="hljs-keyword">class</span>]]) &#123;            <span class="hljs-built_in">NSArray</span> *columnViewArray = (<span class="hljs-built_in">NSArray</span> *)obj;            <span class="hljs-keyword">if</span> (columnViewArray.count &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-type">id</span> columnObj = columnViewArray.firstObject;                <span class="hljs-keyword">if</span> (columnObj &amp;&amp; [columnObj isKindOfClass:[<span class="hljs-built_in">UIView</span> <span class="hljs-keyword">class</span>]]) &#123;                    columnView = (<span class="hljs-built_in">UIView</span> *)columnObj;                &#125;            &#125;        &#125;    &#125;        <span class="hljs-comment">// 2.还用 KVC，取 columnView 的 middleContainerView，修改它的背景颜色即可</span>    <span class="hljs-keyword">if</span> (columnView) &#123;        <span class="hljs-type">id</span> containerObj = [columnView valueForKey:<span class="hljs-string">@&quot;middleContainerView&quot;</span>];        <span class="hljs-keyword">if</span> (containerObj &amp;&amp; [containerObj isKindOfClass:[<span class="hljs-built_in">UIView</span> <span class="hljs-keyword">class</span>]]) &#123;            <span class="hljs-built_in">UIView</span> *selectedRowViewContainer = (<span class="hljs-built_in">UIView</span> *)containerObj;            <span class="hljs-comment">// 最终设置背景框的颜色</span>            selectedRowViewContainer.backgroundColor = <span class="hljs-built_in">UIColor</span>.blackColor;        &#125;    &#125;</code></pre></div><p>到这里我不禁想为什么 Apple 的设计思路这么古怪，这么一个常用的属性为什么不暴露给开发者呢，就叫 selectedRowViewContainer 之类的。</p><p><strong>突然！</strong>我又想到了一个别的方法，既然里层选中行的 View 可以获取到，而容器肯定是包含这个「选中行 View」，那我从「选中行 View」出发，一路找它的父视图，肯定可以找到哇！这种方法的<strong>代码量就少很多了。</strong></p><p>经过测试，最终的代码是：</p><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-built_in">UILabel</span> *label = (<span class="hljs-built_in">UILabel</span> *)[pickerView viewForRow:row forComponent:component];<span class="hljs-built_in">UIView</span> *container = [[[[label superview] superview] superview] superview]; <span class="hljs-comment">// 4个 superView</span></code></pre></div><p><img src="/../image/UIPickerView/ViewHierarchyDiagram.png"></p><p>效果是一样的</p><p><img src="/../image/UIPickerView/Solved.png"></p><p>至此，文章开头说的两个问题圆满解决！🎉庆祝</p><hr><p>说点题外话，这个需求其实是临时加上来的，排期很紧张，我对UIPickerView 这个控件完全没有经验，就想着找一找项目里以前有没有用过，然后把它抄过来。但是一直没有解决好文章提到的第一个问题，加上隔壁 Android 的同事很快就写出来了，越写越急。其实是应该沉下心来的，认真读文档和三方库，而不是没有计划、没有章法地乱试，这个是我自己的毛病，我要改正。</p><hr><p>PS. 在研究这个问题的时候发现，拼多多App 中的「我的资料」页，其中的地区选择包含的 pickerView 也有这个延迟情况。</p><p><img src="/../image/UIPickerView/PinDuoDuo.gif"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Cocoapods你想要了解的一切</title>
    <link href="/2022/09/12/%E5%85%B3%E4%BA%8ECocoapods%E4%BD%A0%E6%83%B3%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E5%88%87/"/>
    <url>/2022/09/12/%E5%85%B3%E4%BA%8ECocoapods%E4%BD%A0%E6%83%B3%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E5%88%87/</url>
    
    <content type="html"><![CDATA[<p><img src="/../image/cocoapods.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CocoaPods 是我现在每天使用的第三方依赖管理库，精通<code>pod install </code>，<code>pod install —repo update</code> ，删除 <code>Podfile.lock</code>文件等操作。</p><p>我从没觉得这有什么了不起的。直到在一次面试中字节跳动的面试官问我：CocoaPods 的原理是什么？</p><p>像我这样年轻的程序员不应该满足于完成日常开发任务，了解下 CocoaPods吧。</p><h1 id="CocoaPods-为什么可以管理第三方依赖？"><a href="#CocoaPods-为什么可以管理第三方依赖？" class="headerlink" title="CocoaPods 为什么可以管理第三方依赖？"></a>CocoaPods 为什么可以管理第三方依赖？</h1><p>我们拉取了一个项目后，往往要在项目目录下执行pod install ，从而将项目的第三方依赖库<strong>下载</strong>下来并<strong>导入</strong>项目中，pod install后会产生一个 xcworkspace 文件，我们打开这个文件，就能在 Xcode 中打开一个已经把第三方依赖库导入的项目，直接 Run 就可以了。</p><p>所以，CocoaPods 管理第三方依赖的奥秘在于<code>pod install</code></p><p>来看下 <code>pod install</code> 的过程（执行命令<code>pod install --verbose</code>）</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pod install --verbose</span> 1.分析依赖Analyzing dependencies Updating spec repositoriesUpdating spec repo `master`<span class="hljs-meta prompt_">  $ </span><span class="language-bash">/usr/bin/git pull</span>  Already up-to-date.Finding Podfile changes  - AFNetworking  - HockeySDKResolving dependencies of `Podfile`Resolving dependencies for target `Pods&#x27; (iOS 6.0)  - AFNetworking (= 1.2.1)  - SDWebImage (= 3.2)    - SDWebImage/CoreComparing resolved specification to the sandbox manifest  - AFNetworking  - HockeySDK2. 下载依赖Downloading dependencies<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Using AFNetworking (1.2.1)</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Using HockeySDK (3.0.0)</span>  - Running pre install hooks    - HockeySDK3. 生成 Pods 项目Generating Pods project  - Creating Pods project  - Adding source files to Pods project  - Adding frameworks to Pods project  - Adding libraries to Pods project  - Adding resources to Pods project  - Linking headers  - Installing libraries    - Installing target `Pods-AFNetworking` iOS 6.0      - Adding Build files      - Adding resource bundles to Pods project      - Generating public xcconfig file at `Pods/Pods-AFNetworking.xcconfig`      - Generating private xcconfig file at `Pods/Pods-AFNetworking-Private.xcconfig`      - Generating prefix header at `Pods/Pods-AFNetworking-prefix.pch`      - Generating dummy source file at `Pods/Pods-AFNetworking-dummy.m`    - Installing target `Pods-HockeySDK` iOS 6.0      - Adding Build files      - Adding resource bundles to Pods project      - Generating public xcconfig file at `Pods/Pods-HockeySDK.xcconfig`      - Generating private xcconfig file at `Pods/Pods-HockeySDK-Private.xcconfig`      - Generating prefix header at `Pods/Pods-HockeySDK-prefix.pch`      - Generating dummy source file at `Pods/Pods-HockeySDK-dummy.m`    - Installing target `Pods` iOS 6.0      - Generating xcconfig file at `Pods/Pods.xcconfig`      - Generating target environment header at `Pods/Pods-environment.h`      - Generating copy resources script at `Pods/Pods-resources.sh`      - Generating acknowledgements at `Pods/Pods-acknowledgements.plist`      - Generating acknowledgements at `Pods/Pods-acknowledgements.markdown`      - Generating dummy source file at `Pods/Pods-dummy.m`  - Running post install hooks  - Writing Xcode project file to `Pods/Pods.xcodeproj`  - Writing Lockfile in `Podfile.lock`  - Writing Manifest in `Pods/Manifest.lock`4. 集成到主项目中，生成 xcworkspace 文件Integrating client project</code></pre></div><h3 id="1-分析依赖"><a href="#1-分析依赖" class="headerlink" title="1. 分析依赖"></a>1. 分析依赖</h3><p>首先读取 Podfile 文件，解析出是否有新增的 pod 需要 install，被删除的 pod 需要 remove。</p><p>然后读取 Podfile.lock文件（如果存在的话），确定上一次 pod install 成功的 pod 版本号。</p><p>最后是解决冲突，根据 <a href="http://semver.org/" title="Semantic Versioning">Semantic Versioning</a> 里定义的原则，确定第三方依赖 pod 的版本号，如果碰到无法解决会报错，开发者需要手动指定 pod 版本号。（中文文档看这里）</p><blockquote><p>Semantic Versioning语义版本规则，定义了pod 的版本号应该怎么写：</p><p><strong>MAJOR.MINOR.PATCH</strong> (主版本号.次版本号.补丁版本号)， 例如 1.12.60<br>如果修改了 API，做了不兼容改造，那么应该修改 MAJOR，<strong>1</strong>.12.60→<strong>2</strong>.0.0<br>如果做了新功能，应该修改 MINOR，1.<strong>12</strong>.60→1.<strong>13</strong>.0<br>如果修复了某些 bug，不影响当前功能，应该修改 PATCH，1.12.<strong>60</strong>→1.12.<strong>80</strong></p></blockquote><h3 id="2-下载依赖"><a href="#2-下载依赖" class="headerlink" title="2. 下载依赖"></a>2. 下载依赖</h3><p>拉取 pod 的源码，放到 Pods 目录下</p><h3 id="3-生成Pods-xcodeproj文件"><a href="#3-生成Pods-xcodeproj文件" class="headerlink" title="3. 生成Pods.xcodeproj文件"></a>3. 生成Pods.xcodeproj文件</h3><blockquote><p><code>xcodeproj</code> 文件是每个Xcode 项目都有的一个文件，里面记录了该项目的工程配置信息</p></blockquote><p>这一步是通过 CocoaPods&#x2F;Xcodeproj 这个 gem 库去完成的。</p><p>由这一步我们可以得出：<strong>CocoaPods 的原理是将所有的依赖库都放在 Pods 项目下，主项目只需要依赖 Pods 项目。这样，pod 源码管理工作就从主项目转到 Pods 项目中。</strong></p><p>在这一阶段，CocoaPods 还会去更新 Podfile.lock 文件、Manifest.lock 文件（该文件是 Podfile.lock 文件的副本，用于避免编译第三方库时可能出现的 crash）</p><h3 id="4-生成xcworkspace"><a href="#4-生成xcworkspace" class="headerlink" title="4. 生成xcworkspace"></a>4. 生成xcworkspace</h3><blockquote><p>xcworkspace 实际上是一个文件夹，里面包含三个子目录：contents.xcworkspacedata以及两个子文件夹 xcshareddata， xcuserdata。contents.xcworkspacedata里记录了当前项目有哪些 project。</p></blockquote><hr><p>最后，点开这个 xcworksapce，就能得到一个「第三方依赖已经准备好了，编译一下就能跑」的项目</p><h1 id="pod-install-和-pod-update-的区别是什么？"><a href="#pod-install-和-pod-update-的区别是什么？" class="headerlink" title="pod install 和 pod update 的区别是什么？"></a>pod install 和 pod update 的区别是什么？</h1><p>区别在于<strong>是否按照Podfile.lock 来安装 pod。</strong></p><p>pod install 会根据 Podfile.lock 中写好的版本号去拉取pod 的源代码。这样做的好处就是可以利用上一次 pod install 成功时的第三方库环境。（如果 Podfile.lock 不存在，那么会进行一次依赖关系分析，确定符合条件的 pod 版本号，最后去拉取 pod ）</p><p>而 pod update 会忽视 Podfile.lock，根据 Podfile 文件，选择「既符合约束条件，尽可能新」的版本号，pod update 成功后会更新 Podfile.lock 文件。</p><blockquote><p>当你修改了 Podfile 文件，那应该用 pod install 安装 pod<br>当你想更新 pod 版本，应该用 pod update，更新 pod</p></blockquote><p>所以官方文档建议，将 Podfile.lock 放入版本控制中，这样就能保证团队里大家都用的是同一套环境（就是各个 pod 的版本一致）。</p><blockquote><p>pod outdated ：如果Podfile.lock 中的 pod 有新版本，这条命令会将对应的新版本罗列出来。所以可以用这条命令查看已经安装的 pod 是否可以更新版本</p></blockquote><h1 id="Podfile-中如果写死了pod版本号，是不是就可以抛弃Podfile-lock-了？"><a href="#Podfile-中如果写死了pod版本号，是不是就可以抛弃Podfile-lock-了？" class="headerlink" title="Podfile 中如果写死了pod版本号，是不是就可以抛弃Podfile.lock 了？"></a>Podfile 中如果写死了pod版本号，是不是就可以抛弃Podfile.lock 了？</h1><p><strong>不行</strong>，理由是 「pod 依赖的 pod 」的版本号可能存在不一致。</p><p>假如项目现在依赖了 A 库，Podfile 中这么写：</p><div class="code-wrapper"><pre><code class="hljs ruby">pod <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;1.0.0&#x27;</span></code></pre></div><p>但是 A 依赖了一个库 B，在 A 的 podspec 文件中是这么定义的：</p><div class="code-wrapper"><pre><code class="hljs ruby">dependency <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;~&gt; 3.0&#x27;</span></code></pre></div><p>那小明跑项目的时候，用的是A（1.0.0）B（3.1.1）。</p><p>但是小花跑项目的时候，就可能是A（1.0.0）B（3.2.9）。</p><p>这时环境就不一致了。</p><p>所以还是得用 <code>Podfile.lock</code> ，跑完把 <code>Podfile.lock</code> 一起提交上去，大家用的就都是同一套环境了。</p><h1 id="除了-CocoaPods，还有哪些选项？"><a href="#除了-CocoaPods，还有哪些选项？" class="headerlink" title="除了 CocoaPods，还有哪些选项？"></a>除了 CocoaPods，还有哪些选项？</h1><p><strong>Carthage</strong>。如果说 CocoaPods 是一个傻瓜式的一键工具，那么 Carthage 就是更轻量级的、自定义的，更灵活的，具体优点是：</p><h2 id="不侵入性"><a href="#不侵入性" class="headerlink" title="不侵入性"></a>不侵入性</h2><p>Carthage 做的工作仅仅是下载 pod 源码以及用 xcodebuild 工具把源码编译成frameworks（仅支持动态库）。需要开发者手动将对应的 framework 链接到项目中。</p><h2 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h2><p>正式因为 Carthage 的不侵入性，所以它不会像 CocoaPods 一样会影响原项目的结构。这让它<strong>容易集成</strong>，也<strong>容易去除</strong>。</p><h2 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h2><p>Carthage 没有 CocoaPods 一样的中心服务器，如果要更新环境或者配置某个 pod 时，直接更新对应 pod，不需要向中心服务器请求数据。</p><h2 id="编译速度快"><a href="#编译速度快" class="headerlink" title="编译速度快"></a>编译速度快</h2><p>使用了CocoaPods的项目，清缓存后重新编译，需要把所有的第三方库编译一遍。而因为 Carthage 是已经把第三方库编译成了frameworks了，于是不需要再一次编译第三方库。</p><hr><p>当然，Carthage 不是没有<strong>缺点：</strong></p><h2 id="看不到源码"><a href="#看不到源码" class="headerlink" title="看不到源码"></a>看不到源码</h2><p>以 framework 方法导入的第三方库在 Xcode 中只能看到头文件，而不能直接看到源代码。</p><h2 id="手动操作多，容易出问题"><a href="#手动操作多，容易出问题" class="headerlink" title="手动操作多，容易出问题"></a>手动操作多，容易出问题</h2><ul><li>需要开发者自己将编译好的xcframework文件拖进项目中，同时设置对应属性。</li></ul><hr><h1 id="Carthage-or-CocoaPods如何选择合适的第三方库管理工具？"><a href="#Carthage-or-CocoaPods如何选择合适的第三方库管理工具？" class="headerlink" title="Carthage or CocoaPods如何选择合适的第三方库管理工具？"></a>Carthage or CocoaPods如何选择合适的第三方库管理工具？</h1><p>在同一个项目中，Carthage 和 CocoaPods 不是「一山不容二虎」的关系，它们可以混用。再加上考虑CocoaPods 对项目的侵入性，一种显而易见的策略是：</p><p>先使用 Carthage，当发现Carthage 无法满足需求时（例如查看源码，第三方库只支持 CocoaPods等），再使用 CocoaPods。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.codetd.com/article/13754374#:~:text=CocoaPods%20%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E5%B0%86%E6%89%80%E6%9C%89%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BA%93%E9%83%BD%E6%94%BE%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BAPods%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E7%84%B6%E8%80%8C%E8%AE%A9%E4%B8%BB%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96Pods%E9%A1%B9%E7%9B%AE%EF%BC%8C%20%E8%BF%99%E6%A0%B7%EF%BC%8C%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E4%BB%BB%E5%8A%A1%E4%BB%8E%E4%B8%BB%E9%A1%B9%E7%9B%AE%E7%A7%BB%E5%88%B0%E4%BA%86Pods%E9%A1%B9%E7%9B%AE%E4%B8%AD%E3%80%82,1.%20Pods%E9%A1%B9%E7%9B%AE%E6%9C%80%E7%BB%88%E4%BC%9A%E7%BC%96%E8%AF%91%E6%88%90%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BAlibPods.a%E7%9A%84%E6%96%87%E4%BB%B6,%20%E4%B8%BB%E9%A1%B9%E7%9B%AE%E5%8F%AA%E8%A6%81%E4%BE%9D%E8%B5%96%E8%BF%99%E4%B8%AA.a%E6%96%87%E4%BB%B6%E5%8D%B3%E5%8F%AF" title="iOS-CocoaPods的原理及Podfile.lock问题">iOS-CocoaPods的原理及Podfile.lock问题</a></li><li><a href="https://www.objc.io/issues/6-build-tools/cocoapods-under-the-hood/" title="CocoaPods Under The Hood">CocoaPods Under The Hood</a></li><li><a href="https://semver.org/" title="Semantic Versioning 2.0.0">Semantic Versioning 2.0.0</a>， <a href="https://www.jianshu.com/p/e2619a7aa60e" title="中文翻译">中文翻译</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hummer 的通信机制</title>
    <link href="/2022/07/25/Hummer%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/07/25/Hummer%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>—— 一个跨端框架应该要怎么通信？</p><p>世界上有很多跨端框架，有自己把底层渲染的工作都包了的，那个叫 Flutter，有那种把小程序装进 App，用 Webview 搞定页面的，用小程序框架来实现跨端的，这个滴滴内部自研有一个，叫<strong>星河</strong>。</p><p>还有一种更为常见，就是在 Android 和 iOS 都实现一套 UI和基础类，然后开发者只需要编写一套业务代码就能给两端用，这种有ReactNative，Weex，还有今天我要说的 Hummer。</p><hr><p>在开发需求的过程中，有一些问题常常萦绕在我的头脑中：</p><p><strong>在 Native 侧需要做什么工作，才能把TypeScript 代码运行起来？</strong></p><p>或者问得更具体点：</p><p><strong>一个 Hello world 的文字怎么才能通过几行 TypeScript 代码，就能显示到手机屏幕上？</strong></p><hr><h1 id="初始化Hummer：安装引擎"><a href="#初始化Hummer：安装引擎" class="headerlink" title="初始化Hummer：安装引擎"></a>初始化Hummer：安装引擎</h1><p><img src="/../image/install_engine.png"></p><p>像汽车一样，想让Hummer运行，车子先要有引擎</p><div class="code-wrapper"><pre><code class="hljs objective-c">[Hummer startEngine:nil];</code></pre></div><p>这行代码做了什么？</p><ol><li><p>加载所有<strong>已经导出的类</strong></p><blockquote><p>什么叫「导出的类 Exported Class」？指的是那些在 Native 侧已经写好了，TypeScript 代码可以使用的类。导出的方法，导出的属性同理。</p></blockquote><blockquote><p>那什么叫<strong>加载</strong>呢？就是把这些Native 类起一个objc 的类名，再起一个 js 类名，然后放入一个 dictionary 中，这样既可以通过 objc 类名获取到这个类，也能通过 js 类名获取到这个类。一类，两名。就像给我家的仆人起一个中文名玛丽，起一个英文名 Mary，那既可以通过「玛丽」呼唤她，也可以通过「Mary」呼唤她。</p></blockquote></li><li><p>加载所有<strong>导出的方法和属性</strong></p></li><li><p>确定导出类的父类关系</p><p>比如我们已经加载了 ABCD 四个导出类，那其中的 A 类可能是继承B 类的，那么就要把这个父类关系给记录下来，记录在 A 类的superClassReference属性中即可（注意这里确定的 是js组件的继承关系，比如 Text 继承自 View）</p></li></ol><p>点火的结果是我们得到了一个 HMExportManager ，它里边有许许多多加载好的<strong>类、方法和属性</strong>。这时Hummer 已经有了动力来源了。</p><h2 id="好像忘了点东西？"><a href="#好像忘了点东西？" class="headerlink" title="好像忘了点东西？"></a>好像忘了点东西？</h2><p>在开始的开始，<strong>导出类是哪里来的？</strong> 我没有写导出的代码，那一定是Hummer 自己写的，神奇的事情发生在这里（我们随便找个类）</p><p><img src="/../image/export.png"></p><p>点进去看实现：</p><p>用到了__attribute__((section(“name”))) ,这个编译属性，改变了数据的存储特性。也就是说通过魔法一般的代码，我们得以在编译链接的时候就把对应的结构体（也就是 HMExportStruct）写到可执行文件 Mach-O 中，在后续的初始化代码中能读出来。</p><blockquote><p><a href="https://developer.arm.com/documentation/dui0474/g/using-scatter-files/using---attribute----section--name-----to-place-code-and-data" title="ARM 文档">ARM 文档</a>在这里，有兴趣就点去看看吧。<br>used 参数是告诉编译器：不管我用不用都<strong>不需要</strong>优化掉这个函数。这里<a href="https://www.jianshu.com/p/6fc9974f515a" title="有一篇文章">有一篇文章</a>讲了怎么使用这个编译属性</p></blockquote><p><strong>于是我们的疑惑得以解开了：</strong></p><blockquote><p>举个<strong>栗子</strong>🌰给观众朋友们整明白点：<br>我们在 .m 文件中写下 HM_EXPORT_CLASS(Loading, HMActivityIndicatorView)，<br>就足以让编译器把对应的 __hm_export_class_Loding__ 结构体写到 Mach-O 文件中，最后在startEngine 的时候就能获取到对应的导出类。</p></blockquote><h1 id="准备控制器：执行-JS-代码的必要条件"><a href="#准备控制器：执行-JS-代码的必要条件" class="headerlink" title="准备控制器：执行 JS 代码的必要条件"></a>准备控制器：执行 JS 代码的必要条件</h1><p>通过 startEngine，我们的 Hummer 项目在客观上有了上路奔驰的能力，但是，还没有一个操作系统，没有油门、方向盘、换挡杆等一系列跟车子交流的能力，我们无法（<strong>从 JS 侧</strong>）控制Hummer框架。</p><p><img src="/../image/driver.png"></p><p>所以这时我们还需要初始化这个「<strong>中间者</strong>」，它就是：</p><p><strong>HMJSContext</strong>：<strong>跨端层</strong>，负责 Native 和 JS 之间的通信。</p><div class="code-wrapper"><pre><code class="hljs objective-c">// HMViewController.m- (void)renderWithScript:(NSString *)script &#123;   ...    //渲染脚本之前 需要注册bridge    HMJSContext *context = [HMJSContext contextInRootView:self.hmRootView];    self.context = context;   ...        //执行脚本    [context evaluateScript:script fileName:self.URL];   ...&#125;</code></pre></div><p>初始化 HMJSContext ，有五件事情要做</p><ol><li><p>读取 Hummer bundle 文件中的 builtin.js 文件</p></li><li><p><strong>初始化 HMJSCExecutor（这个是 context 的核心，作用后面讲）</strong></p></li><li><p><strong>执行 builtin.js</strong></p></li><li><p>把 Native 端的类信息（startEngine 的时候生成的），包装成 JS 兼容的格式</p></li><li><p>把上面包装的信息注册到 JS 侧</p></li></ol><p>&amp;#x20;先做个结论：<strong>HMJSContext 初始化之后，车子就有了方向盘，就有了点火器，就有了油门，有了一切该有的，只要来个人就能把这辆车开起来了。</strong></p><hr><p>然后我们再细看这五件事情。虽然有五件，但是只有两件事需要说</p><ul><li><p>初始化 HMJSCExecutor</p></li><li><p>执行 builtin.js</p></li></ul><p>可以把HMJSCExecutor 看做是HMJSContext的<strong>打手</strong>，嫡系，核心下属，因为Executor，听名字就知道，就是负责 execute的，<strong>「执行 JS 代码，以及监听 JS 调用 Native 的回调。」</strong></p><p>来看看它的初始化函数</p><div class="code-wrapper"><pre><code class="hljs objective-c">- (instancetype)init &#123;...    // 共用一个 JS 环境    if (!virtualMachineRef) &#123;        virtualMachineRef = JSContextGroupCreate();    &#125;...    [HMExecutorMap setObject:self forKey:[NSValue valueWithPointer:_contextRef]];    // 注入对象        // 生成 JS 字符串    JSStringRef hummerCallString = JSStringCreateWithUTF8CString(&quot;hummerCall&quot;);    JSStringRef hummerCreateString = JSStringCreateWithUTF8CString(&quot;hummerCreate&quot;);    ...    JSObjectRef globalThis = JSContextGetGlobalObject(_contextRef);    // 创建 C 函数的 bridge    JSObjectRef nativeLoggingHookFunction = JSObjectMakeFunctionWithCallback(_contextRef, NULL, &amp;nativeLoggingHook);    JSObjectRef inlineHummerCallFunction = JSObjectMakeFunctionWithCallback(_contextRef, NULL, &amp;hummerCall);    ...    JSValueRef exception = NULL;        // 把 bridge 绑定到 JS 环境的 Global 对象上, 后面可以通过 globalThis.method() 来调用这里绑定好的函数    JSObjectSetProperty(_contextRef, globalThis, nativeLoggingHookStringRef, nativeLoggingHookFunction, kJSPropertyAttributeReadOnly | kJSPropertyAttributeDontDelete, &amp;exception);    JSObjectSetProperty(_contextRef, globalThis, hummerCallString, inlineHummerCallFunction, kJSPropertyAttributeReadOnly | kJSPropertyAttributeDontDelete, &amp;exception);    ...&#125;</code></pre></div><blockquote><p>JSObjectMakeFunctionWithCallback：把 C 函数的 callback 注册到 JS 侧，比如JS 调用hummerCall时，就会直接调用 C 函数「hummerCall」</p></blockquote><p>一句话概括就是：注册了一些 <strong>C 函数</strong>给 JS。</p><hr><p>等等，写到这儿我已经有点迷糊了，简单概括一下</p><p><strong>Hummer 有了引擎之后，我们需要有一个HMJSContext来控制它，于是就得去初始化这玩意儿：创建一个HMJSCExecutor，注册了一些 C 函数给 JS。</strong></p><p>OK，我们继续。</p><p>那接下来就是说说注册的都是些什么函数？</p><ol><li><p>hummerCall：js 侧调用 Native方法（类方法和成员方法）</p></li><li><p>hummerCreate：创建Native对象，并返回 js 指针来持有这个对象</p></li><li><p>hummerGetProperty：（获取对象的属性值）</p></li><li><p>hummerSetProperty：（设置对象的属性值）</p></li><li><p>hummerCallFunction：（调用闭包函数 closure）</p></li></ol><blockquote><p>这五个函数，都会在执行 builtin.js 文件的时候使用到。所以注意看index.ts，HummerBase.ts，injectClassModel.ts这几个文件</p></blockquote><p>不管是hummerCall 还是hummerGetProperty、hummerSetProperty，他们都调用了下面这个函数：</p><div class="code-wrapper"><pre><code class="hljs objective-c">- (JSValueRef)hummerGetSetPropertyWithArgumentCount:(size_t)argumentCount                                           arguments:(const JSValueRef _Nonnull[])arguments                                            isSetter:(BOOL)isSetter &#123;                          1. 判断是类方法还是成员方法    2. 根据 arguments 获取到 target, method 和 methodSignature    3. 组装成 NSInvocation 并转发消息    4. 返回结果                &#125;</code></pre></div><p><strong>这就是 HMJSCExecutor 的初始化工作。</strong></p><hr><h3 id="初始化-HMJSContext-的第二件值得一说的事"><a href="#初始化-HMJSContext-的第二件值得一说的事" class="headerlink" title="初始化 HMJSContext 的第二件值得一说的事"></a>初始化 HMJSContext 的第二件值得一说的事</h3><p>执行 builtin.js。</p><p>找一下，发现在这儿</p><p><img src="/../image/built.png"></p><p>但是这个打开一看，您猜怎么着？混淆过的，看不了。那怎么办呢？把 Hummer 工程一整个 clone 下来，整这个路径：Hummer&#x2F;iOS&#x2F;builtin&#x2F;src&#x2F;。</p><p>底下有若干个文件，据可靠消息，这几个文件就是混淆后的 builtin.js 文件</p><h4 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h4><p>这个文件是给 globalThis 注册很多方法，但是<strong>没有调用</strong>，比如<strong>hummerLoadClass <strong>（这个是个非常重要的方法，执行完了 builtin.js 后，Native 侧又</strong>特地调用</strong>了这个 <strong>hummerLoadClass</strong>，在HMJSContext#init ）</p><blockquote><p><strong>hummerLoadClass</strong> 的作用是：<strong>将Native导出类的信息全部注册到 JS 侧</strong>。入参就是一个 JSON 字符串，在HMJSContext#init() 的倒数第二行可以看到具体的执行代码</p></blockquote><h4 id="HummerBase-ts"><a href="#HummerBase-ts" class="headerlink" title="HummerBase.ts"></a>HummerBase.ts</h4><p>据说是所有注册到 js 侧的类的基类</p><h4 id="injectClassModel-ts"><a href="#injectClassModel-ts" class="headerlink" title="injectClassModel.ts"></a>injectClassModel.ts</h4><p>上面的<strong>hummerLoadClass</strong> 注册信息时，循环调用<strong>injectClassModel</strong> 方法来完成注册的。调用一次，注册一个导出类的信息。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectClassModel</span>(<span class="hljs-params">jsClassName: string, classModel: ClassModel, classModelMap: Record&lt;string, ClassModel | <span class="hljs-literal">undefined</span> | <span class="hljs-literal">null</span>&gt;</span>): <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">HummerBase</span> | <span class="hljs-literal">undefined</span> &#123;    <span class="hljs-keyword">let</span> jsClass = <span class="hljs-title class_">HummerBase</span>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNotEmptyString</span>(classModel.<span class="hljs-property">superClassName</span>) &amp;&amp; classModelMap[classModel.<span class="hljs-property">superClassName</span>]) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> globalThis[classModel.<span class="hljs-property">superClassName</span>] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;            <span class="hljs-comment">//  0. 有父类并且父类没有注入则先注入父类</span>            <span class="hljs-keyword">const</span> innerLoaderClassModel = classModelMap[classModel.<span class="hljs-property">superClassName</span>]            <span class="hljs-keyword">if</span> (innerLoaderClassModel) &#123;                <span class="hljs-keyword">const</span> superClass = <span class="hljs-title function_">injectClassModel</span>(classModel.<span class="hljs-property">superClassName</span>, innerLoaderClassModel, classModelMap)                <span class="hljs-keyword">if</span> (superClass) &#123;                    jsClass = superClass                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            jsClass = globalThis[classModel.<span class="hljs-property">superClassName</span>]        &#125;    &#125;    jsClass = <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> jsClass &#123; &#125;    classModel.<span class="hljs-property">methodPropertyList</span>?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">methodPropertyModel</span> =&gt;</span> &#123;        <span class="hljs-comment">// 这里是重点，但是没看懂</span>        <span class="hljs-keyword">const</span> prototypeOrClsss = methodPropertyModel.<span class="hljs-property">isClass</span> ? jsClass : jsClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>        <span class="hljs-comment">// 注入方法</span>        <span class="hljs-keyword">if</span> (methodPropertyModel.<span class="hljs-property">isMethod</span>) &#123;            prototypeOrClsss[methodPropertyModel.<span class="hljs-property">nameString</span>] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args: unknown[]</span>) &#123;                <span class="hljs-keyword">if</span> (isOfType&lt;<span class="hljs-title class_">HummerBase</span>&gt;(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;_private&#x27;</span>)) &#123;                    <span class="hljs-comment">// 之前在 Native 给 globalThis 注册的 hummerCall 在这时候派上用场了</span>                    <span class="hljs-keyword">return</span> globalThis.<span class="hljs-title function_">hummerCall</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_private</span>, jsClassName, methodPropertyModel.<span class="hljs-property">nameString</span>, ...args)                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 类方法调用</span>                    <span class="hljs-keyword">return</span> globalThis.<span class="hljs-title function_">hummerCall</span>(jsClassName, methodPropertyModel.<span class="hljs-property">nameString</span>, ...args)                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(prototypeOrClsss, methodPropertyModel.<span class="hljs-property">nameString</span>, &#123;                <span class="hljs-comment">// getter setter 注册</span>                <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">this</span>: HummerBase | unknown</span>) &#123;                    <span class="hljs-keyword">if</span> (isOfType&lt;<span class="hljs-title class_">HummerBase</span>&gt;(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;_private&#x27;</span>)) &#123;                        <span class="hljs-keyword">return</span> globalThis.<span class="hljs-title function_">hummerGetProperty</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_private</span>, jsClassName, methodPropertyModel.<span class="hljs-property">nameString</span>)                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">return</span> globalThis.<span class="hljs-title function_">hummerGetProperty</span>(jsClassName, methodPropertyModel.<span class="hljs-property">nameString</span>)                    &#125;                &#125;,                <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">this</span>: HummerBase | unknown, newValue: unknown</span>) &#123;                    <span class="hljs-keyword">if</span> (isOfType&lt;<span class="hljs-title class_">HummerBase</span>&gt;(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;_private&#x27;</span>)) &#123;                        <span class="hljs-keyword">return</span> globalThis.<span class="hljs-title function_">hummerSetProperty</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_private</span>, jsClassName, methodPropertyModel.<span class="hljs-property">nameString</span>, newValue)                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">return</span> globalThis.<span class="hljs-title function_">hummerSetProperty</span>(jsClassName, methodPropertyModel.<span class="hljs-property">nameString</span>, newValue)                    &#125;                &#125;            &#125;)        &#125;    &#125;)    <span class="hljs-comment">// 给 jsClass 添加 name 属性，值是 jsClassName（比如 &#x27;Text&#x27;）       </span>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(jsClass, <span class="hljs-string">&#x27;name&#x27;</span>, &#123; <span class="hljs-attr">value</span>: jsClassName &#125;)    <span class="hljs-comment">// 将 jsClass 挂载到 globalThis 上</span>    globalThis[jsClassName] = jsClass    <span class="hljs-keyword">return</span> jsClass <span class="hljs-comment">// 不返也行，反正也没用</span>&#125;</code></pre></div><h1 id="终于：执行-JS-代码"><a href="#终于：执行-JS-代码" class="headerlink" title="终于：执行 JS 代码"></a>终于：执行 JS 代码</h1><p>等执行了 builtin.js, 再执行 JS 函数 <strong>hummerLoadClass</strong>，Hummer 这车引擎有了，控制器方向盘油门什么的也齐了，可以开车上路，执行业务开发者写的 ts 代码了，比如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Hummer</span>,<span class="hljs-title class_">View</span>, <span class="hljs-title class_">Text</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@hummer/hummer-front&#x27;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">RootView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">View</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">super</span>();    <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span> = &#123;      <span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;100%&#x27;</span>,      <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;100%&#x27;</span>,      <span class="hljs-attr">alignItems</span>: <span class="hljs-string">&#x27;flex-start&#x27;</span>,      <span class="hljs-attr">justifyContent</span>: <span class="hljs-string">&#x27;center&#x27;</span>    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initElement</span>()  &#125;  <span class="hljs-title function_">initElement</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">appendText</span>(<span class="hljs-string">&#x27;~ Hello Hummer ~&#x27;</span>)  &#125;  <span class="hljs-title function_">appendText</span>(<span class="hljs-params">message:string</span>)&#123;    <span class="hljs-keyword">var</span> text = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>()    text.<span class="hljs-property">style</span> = &#123;      <span class="hljs-attr">fontSize</span>: <span class="hljs-number">20</span>,    &#125;    text.<span class="hljs-property">text</span> = message    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">appendChild</span>(text);  &#125;&#125;<span class="hljs-comment">// 根页面渲染</span><span class="hljs-title class_">Hummer</span>.<span class="hljs-title function_">render</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RootView</span>());</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们收拾一下思路，问出一个可以概括本篇文章的问题：</p><p><strong>如何实现一个跨端框架？</strong></p><p>首先，你要在 Native 侧要实现很多很多个类，这样js 侧才有东西可以调用。不仅要实现，还得把这些类信息记录下来放到一个对象中，在运行的时候 js 侧通过这个对象能找到这些类。</p><p>其次，你要创建 js 侧调用 Native的口子，要把某些必不可少的 C 函数注册到 js 侧，执行 Hummer 内置的builtin.js ，把 js 环境倒腾好。js 侧要只能有哪些类，并且能调用这些类，创建 Native 对象，跟 Native 对象交互。</p><p><strong>此时，跨端框架已经准备好运行业务代码了。</strong></p><hr><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><p>跨端框架 Hummer 通信机制 - iOS 版（滴滴内部资料）</p></li><li><p><a href="https://www.jianshu.com/p/6fc9974f515a?u_atoken=4e84bfbb-0d2e-4dd6-99bc-bf376df6aa9f&u_asession=01-huAtRfx0hH5UHzwe8Lh1s7DC96dFR0qdNL_EgJm1fu2KgW8m8woPJnOYLo65jzIX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K-99uxyLsFnLLOQ3YDOLFetPIF6hypDqzN_tz02ZDuS7GBkFo3NEHBv0PZUm6pbxQU&u_asig=053oswMXvKuIBz4WVlP8kItSqk3YST1EJuHkD2nP-UJVOYAznuMy2S0H_UNoC1GqgFS_0k5IkAplJG2_ZzculU_tdvMS4FknKIlUSJscxog5mvHbREZZYDHcYd9TT8p6p9mHIow13wRLoBvk1stpyXtRF3Q4RMUR8-fDCOzTWd9dT9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzWa_ZlFcbc1GNzPML23AOVWwB8kYhvUlAIbkfK006hx-HLC90DffcRgc58NhmjbgM-3h9VXwMyh6PgyDIVSG1W-VyZZSvkD2KpzhcSb3FsM0-ugCNFY0FZyNegwerOk566aGIEHC8TOnb34QgAOin7eHYTj2zIIrFgiM-Kc-R44omWspDxyAEEo4kbsryBKb9Q&u_aref=V231vK39fNOpAG/085YUfwQtIvQ=" title="__data在编译阶段处理协议">__data在编译阶段处理协议</a></p></li><li><p><a href="https://developer.arm.com/documentation/dui0474/g/using-scatter-files/using---attribute----section--name-----to-place-code-and-data" title="Using ">Using </a><a href="https://developer.arm.com/documentation/dui0474/g/using-scatter-files/using---attribute----section--name-----to-place-code-and-data" title="attribute"><strong>attribute</strong></a><a href="https://developer.arm.com/documentation/dui0474/g/using-scatter-files/using---attribute----section--name-----to-place-code-and-data" title="((section(&quot;name&quot;))) to place code and data">((section(“name”))) to place code and data</a>（就那个宏的文档）</p></li><li><p><a href="https://docs.ultralig.ht/docs/calling-a-c-function-from-js" title="Calling a C Function From JS">Calling a C Function From JS</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>跨端框架Hummer 是如何渲染的？（iOS 版)</title>
    <link href="/2022/07/25/%E8%B7%A8%E7%AB%AF%E6%A1%86%E6%9E%B6Hummer%20%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E7%9A%84%EF%BC%9F%EF%BC%88iOS%20%E7%89%88%EF%BC%89/"/>
    <url>/2022/07/25/%E8%B7%A8%E7%AB%AF%E6%A1%86%E6%9E%B6Hummer%20%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E7%9A%84%EF%BC%9F%EF%BC%88iOS%20%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hummer.didi.cn/doc#/zh-CN/" title="Hummer"><strong>Hummer</strong></a>是目前滴滴货运司机端正在使用的跨端框架，之前在开发需求的时候碰到了诡异的布局问题，由于自己是刚接触，完全不知道从哪里下手排查问题，于是请来了兄弟部门 Hummer iOS 现在的维护者史广远，看着他一步一步地打断点，打日志，最终成功定位问题，给出了解决方案。心里敬佩得很。</p><p>所以既为了以后开发能够有独立排查问题的能力，也为了提高自己对于跨端技术的理解，这就来整理了下Hummer 的渲染机制：</p><p><img src="/../image/hummerRender/hummer.png"></p><hr><p>从我们的题目开始：<strong>Hummer在 iOS 侧是如何渲染的？</strong></p><p>如同把大象塞进冰箱，我分为 5 步：</p><ol><li>创建：把组件实例化，创建出来</li><li>设置：设置它的 style 和属性</li><li>渲染：把准备好的组件添加到 yoga 节点树上，也是添加到屏幕上</li><li>标记：标记需要重新计算、刷新的组件</li><li>布局：调用 yoga 对组件进行布局</li></ol><hr><blockquote><p>Hummer 既可以用 TypeScript 写，也可以用Tenon 写，本文采用第一种写法。</p></blockquote><p>首先来看用<strong>TypeScript</strong> 写的业务代码：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Hummer</span>,<span class="hljs-title class_">View</span>, <span class="hljs-title class_">Text</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@hummer/hummer-front&#x27;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">RootView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">View</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">super</span>();    <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span> = &#123;      <span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;100%&#x27;</span>,      <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;100%&#x27;</span>,      <span class="hljs-attr">alignItems</span>: <span class="hljs-string">&#x27;flex-start&#x27;</span>,      <span class="hljs-attr">justifyContent</span>: <span class="hljs-string">&#x27;center&#x27;</span>    &#125;    <span class="hljs-comment">// 创建了一个 Text 组件</span>    <span class="hljs-keyword">var</span> text = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>()    text.<span class="hljs-property">style</span> = &#123;      <span class="hljs-attr">fontSize</span>: <span class="hljs-number">20</span>    &#125;    text.<span class="hljs-property">text</span> = <span class="hljs-string">&#x27;~ Hello Hummer ~&#x27;</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">appendChild</span>(text);  &#125;&#125;<span class="hljs-comment">// 根页面渲染</span><span class="hljs-title class_">Hummer</span>.<span class="hljs-title function_">render</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RootView</span>());</code></pre></div><p>简单，天真，几乎只写了一个 <strong>Text</strong> 组件。</p><h3 id="1-实例化：「特别鸣谢你制造更欢乐的我」"><a href="#1-实例化：「特别鸣谢你制造更欢乐的我」" class="headerlink" title="1 实例化：「特别鸣谢你制造更欢乐的我」"></a>1 实例化：「特别鸣谢你制造更欢乐的我」</h3><p>在执行 var text &#x3D; new Text() 时，在 Native 侧就得<strong>创建一个 HMLabel实例，并且要把实例装入一个 JS 对象中返回给 JS</strong>，它还得持有一下。这一步交给谁来做 ——<strong>hummerCreate</strong>: 函数。</p><blockquote><p>1 调用 HumemrBase 的 constructor 方法<br>2 根据 name 属性获取 className &amp; check cache<br>3调用 globalThis 的 hummerCreate 方法生成 native 对应的视图实例 &amp; 被 this._ptivate 持有<br>——《跨端框架 Hummer 通信机制 - iOS 版》</p></blockquote><div class="code-wrapper"><pre><code class="hljs objective-c">JSValueRef _Nullable hummerCreate(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef _Nonnull arguments[], JSValueRef *exception) &#123;    HMAssertMainQueue();     if (argumentCount &lt; 2) &#123;        HMLogError(HUMMER_CREATE_ERROR);        return NULL;    &#125;    HMJSCExecutor *executor = (HMJSCExecutor *) [HMExecutorMap objectForKey:[NSValue valueWithPointer:JSContextGetGlobalContext(ctx)]];    NSString *className = [executor convertValueRefToString:arguments[0] isForce:NO];    if (className.length == 0) &#123;        HMLogError(HUMMER_CREATE_ERROR);        return NULL;    &#125;    // 获取导出类    HMExportClass *exportClass = HMExportManager.sharedInstance.jsClasses[className];    NSString *objcClassName = exportClass.className;    if (objcClassName.length == 0) &#123;        HMLogError(HUMMER_CREATE_CLASS_NOT_FOUND, className);        return NULL;    &#125;    // className 是 Hummer 侧的类名（比如 Text）    // objcClassName 是 Native 侧的类名（比如 HMLabel）    Class clazz = NSClassFromString(objcClassName);    if (!clazz) &#123;        HMLogError(HUMMER_CREATE_CLASS_NOT_FOUND, className);        return NULL;    &#125;    // jscall回调    HMJSContext *context = [[HMJSGlobal globalObject] currentContext:executor];        // 创建不透明指针    NSObject *opaquePointer = NULL;    NSMutableArray&lt;HMBaseValue *&gt; *argumentArray = nil;    for (int i = 2; i &lt; argumentCount; ++i) &#123;        HMBaseValue *value = [[HMJSCStrongValue alloc] initWithValueRef:arguments[i] executor:executor];        if (!argumentArray) &#123;            argumentArray = [NSMutableArray arrayWithCapacity:argumentCount - 2];        &#125;        if (value) &#123;            [argumentArray addObject:value];        &#125;    &#125;#ifdef HMDEBUG    [HMJSCallerInterceptor callNativeWithClassName:className functionName:@&quot;constructor&quot; objectRef:nil args:argumentArray context:context];#endif    HMCurrentExecutor = executor;    // 支持 HMJSObject，如果不支持则回退 init    // 不判断 argumentCount &gt; 2，因为 UIView 必须调用 HMJSObject 初始化方法    if ([clazz conformsToProtocol:@protocol(HMJSObject)]) &#123;        opaquePointer = (id) [(id) [clazz alloc] initWithHMValues:argumentArray];    &#125; else &#123;        HMOtherArguments = argumentArray.copy;        opaquePointer = [[clazz alloc] init];    &#125;    HMCurrentExecutor = nil;    HMOtherArguments = nil;    if (!opaquePointer) &#123;        HMLogError(HUMMER_CAN_NOT_CREATE_NATIVE_OBJECT, className);        return NULL;    &#125;    // 关联 hm_value    opaquePointer.hmValue = [[HMJSCStrongValue alloc] initWithValueRef:arguments[1] executor:executor];    // 引用计数 +1    HMLogDebug(HUMMER_CREATE_TEMPLATE, className);    JSClassDefinition hostObjectClassDef = kJSClassDefinitionEmpty;    hostObjectClassDef.version = 0;    hostObjectClassDef.attributes = kJSClassAttributeNoAutomaticPrototype;    hostObjectClassDef.finalize = hummerFinalize;    JSClassRef hostObjectClass = JSClassCreate(&amp;hostObjectClassDef);    // 填充不透明指针    JSObjectRef objectRef = JSObjectMake(ctx, hostObjectClass, (__bridge void *) opaquePointer);    if (objectRef) &#123;        CFRetain((__bridge CFTypeRef) opaquePointer);    &#125;    JSClassRelease(hostObjectClass);    return objectRef;&#125;</code></pre></div><p>这个函数做了：</p><ol><li>根据 Hummer 侧传过来的消息获取到了在 Native 侧注册的类</li><li>创建这个类</li><li>创建不透明指针，把这个类填到不透明指针当中</li><li>返回不透明指针</li></ol><p><strong>再次强调</strong>：最终返回的是<strong>JSObjectRef</strong> 对象，不是简单的 <strong>HMLabel</strong> 对象。</p><p>我猜测这样做的原因是 Native需要跟 JavaScriptCore 进行通信，只创建一个 HMLabel 你怎么跟 Hummer 侧进行交流，后续 Hummer 怎么拿到这个对象进行设置？</p><h3 id="2-1设置-style："><a href="#2-1设置-style：" class="headerlink" title="2.1设置 style："></a>2.1设置 style：</h3><p>HMLabel 创建出来后，就需要设置它的样式，比如 height、width等。Hummer 侧会一个发 setStyle 的信号，Native会调用hm_setStyle: 方法</p><blockquote><p>这层转化是通过 HM_EXPORT_PROPERTY 这个宏实现的</p></blockquote><div class="code-wrapper"><pre><code class="hljs objective-c">- (void)hm_setStyle:(HMBaseValue *)style &#123;    // 转化交给 HMJSCExecutor 完成    id styleObject = style.toDictionary;    NSDictionary *styleDic = nil;    if ([styleObject isKindOfClass:NSDictionary.class]) &#123;        styleDic = styleObject;    &#125;    if (styleDic.count == 0) &#123;        HMLogError(@&quot;style 必须有键值对&quot;);        return;    &#125;    // 把 style 信息划分成三个部分：布局、属性（样式）、过渡信息（动画相关）    NSMutableDictionary&lt;NSString *, NSObject *&gt; *layoutInfo = NSMutableDictionary.dictionary;    NSMutableDictionary&lt;NSString *, NSObject *&gt; *attributes = NSMutableDictionary.dictionary;    NSMutableDictionary&lt;NSString *, NSObject *&gt; *transitions = NSMutableDictionary.dictionary;    [styleDic enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;        if (![key isKindOfClass:NSString.class]) &#123;            return;        &#125;                // 比如 left，flexDirection        if ([[self hm_layoutInfoKeys] containsObject:key]) &#123;            layoutInfo[key] = obj;        &#125; else if ([[self hm_transtionInfoKeys] containsObject:key]) &#123;        // 比如 transitionDelay，            transitions[key] = obj;        &#125; else &#123;        // 比如 backgroundColor            attributes[key] = obj;        &#125;        // 布局、属性和过渡信息可以看文档，看看有什么        // https://hummer.didi.cn/doc#/zh-CN/normal_view_style    &#125;];    NSMutableDictionary&lt;NSString *, NSObject *&gt; *mutableStyleDictionary = self.hm_styleStore.mutableCopy;    if (!mutableStyleDictionary) &#123;        mutableStyleDictionary = [NSMutableDictionary dictionaryWithCapacity:layoutInfo.count + attributes.count + transitions.count];    &#125;    // 把分好的三部分又装了回去，让 self.hm_styleStore 持有    self.hm_styleStore = nil;    [mutableStyleDictionary addEntriesFromDictionary:layoutInfo];    [mutableStyleDictionary addEntriesFromDictionary:attributes];    [mutableStyleDictionary addEntriesFromDictionary:transitions];    self.hm_styleStore = mutableStyleDictionary;    ...    [attributes enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSObject *obj, BOOL *stop) &#123;        // 过滤需要动画的属性，通过动画展示        if (self.hm_transitionAnimation &amp;&amp; [self.hm_transitionAnimation.needAnimations.allKeys containsObject:key]) &#123;            [transitionAnimations addEntriesFromDictionary:@&#123;key: obj&#125;];        &#125; else &#123;            // layoutInfo、attributes 就通过这个设置            [self hm_configureWithTarget:self cssAttribute:key value:obj converterManager:HMAttrManager.sharedManager];        &#125;    &#125;];        ...    // 标记：该结点需要重新计算位置    [self hm_markDirty];&#125;</code></pre></div><p>用我易（粗）懂（暴）的语言说就是：</p><ol><li>HMJSCExecutor 把 Hummer 侧的 style 字典转成NSDictionary</li><li>把NSDictionary里的元素划分成三种不同的 style：布局、属性、过渡相关的</li><li>设置给hm_styleStore持有</li><li>通过hm_configureWithTarget: cssAttribute: value:converterManager: 函数实际去设置对应的 style 值</li></ol><h3 id="2-2-设置-Property-（比如-Text-的-text-属性）"><a href="#2-2-设置-Property-（比如-Text-的-text-属性）" class="headerlink" title="2.2 设置 Property （比如 Text 的 text 属性）"></a>2.2 设置 Property （比如 Text 的 text 属性）</h3><div class="code-wrapper"><pre><code class="hljs objective-c">// 不管是 get 还是 set 都是调用这个方法- (JSValueRef)hummerGetSetPropertyWithArgumentCount:(size_t)argumentCount arguments:(const JSValueRef _Nonnull[])arguments isSetter:(BOOL)isSetter &#123;    ...    // 这里为什么要把 argument[0] 转成 JSObjectRef？    JSObjectRef objectRef = NULL;    if (JSValueIsObject(self.contextRef, arguments[0])) &#123;        JSValueRef exception = NULL;        objectRef = JSValueToObject(self.contextRef, arguments[0], &amp;exception);        [self popExceptionWithErrorObject:&amp;exception];    &#125;    ...    // 获取对应的类名    NSString *className = [self convertValueRefToString:arguments[objectRef ? 1 : 0] isForce:NO];    if (className.length == 0) &#123;        return NULL;    &#125;    NSString *propertyName = [self convertValueRefToString:arguments[objectRef ? 2 : 1] isForce:NO];    if (propertyName.length == 0) &#123;        return NULL;    &#125;    id target = nil;    SEL selector = nil;    NSMethodSignature *methodSignature = nil;    [self hummerExtractExportWithFunctionPropertyName:propertyName objectRef:objectRef target:&amp;target selector:&amp;selector methodSignature:&amp;methodSignature isSetter:isSetter jsClassName:className];    // 通过导出类、导出方法，获取到了 Native 类、对应的方法    ...    // 转发消息，调用原生方法    return [self hummerCallNativeWithArgumentCount:argumentCount arguments:arguments target:target selector:selector methodSignature:methodSignature];&#125;- (JSValueRef)hummerCallNativeWithArgumentCount:(size_t)argumentCount arguments:(JSValueRef const[])arguments target:(id)target selector:(SEL)selector methodSignature:(NSMethodSignature *)methodSignature &#123;    ...    BOOL isClass = object_isClass(target);    NSMutableArray&lt;HMBaseValue *&gt; *otherArguments = nil;    HMCurrentExecutor = self;    // 隐含着 numerOfArguments + 0/1 &lt;= argumentCount    for (NSUInteger i = methodSignature.numberOfArguments + (isClass ? 0 : 1); i &lt; argumentCount; ++i) &#123;        // 多余的转数组        HMBaseValue *hummerValue = [[HMJSCStrongValue alloc] initWithValueRef:arguments[i] executor:HMCurrentExecutor];        if (!otherArguments) &#123;            otherArguments = [NSMutableArray arrayWithCapacity:argumentCount - methodSignature.numberOfArguments];        &#125;        if (hummerValue) &#123;            [otherArguments addObject:hummerValue];        &#125;    &#125;    // 存储额外参数    HMOtherArguments = otherArguments.copy;    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];    invocation.target = target;    invocation.selector = selector;    // 后续做循环，都是临时变量，如果不做 retain，会导致野指针    [invocation retainArguments];    // 参数    // 本质为 MIN(methodSignature.numberOfArguments, argumentCount - (isClass : 0 : 1))，主要为了防止无符号数字溢出    for (NSUInteger i = 2; i &lt; MIN(methodSignature.numberOfArguments + (isClass ? 0 : 1), argumentCount) - (isClass ? 0 : 1); ++i) &#123;        const char *objCType = [methodSignature getArgumentTypeAtIndex:i];        HMEncodingType type = HMEncodingGetType(objCType);        id param = nil;        if (type == HMEncodingTypeBlock) &#123;            // Block            param = [(HMJSCExecutor *) HMCurrentExecutor convertValueRefToFunction:arguments[i + (isClass ? 0 : 1)]];        &#125; else if (type == HMEncodingTypeObject) &#123;            // HMJSCValue            param = [[HMJSCStrongValue alloc] initWithValueRef:arguments[i + (isClass ? 0 : 1)] executor:HMCurrentExecutor];        &#125; else if (HMEncodingTypeIsCNumber(type)) &#123;            // js 只存在 double 和 bool 类型，但原生需要区分具体类型。            param = [(HMJSCExecutor *) HMCurrentExecutor convertValueRefToNumber:arguments[i + (isClass ? 0 : 1)] isForce:NO];        &#125; else &#123;            HMLogError(HUMMER_UN_SUPPORT_TYPE_TEMPLATE, objCType);        &#125;        [invocation hm_setArgument:param atIndex:i encodingType:type];    &#125;    // 拼装完毕，执行方法    [invocation invoke];    HMOtherArguments = nil;    // 返回值    JSValueRef returnValueRef = NULL;    const char *objCReturnType = methodSignature.methodReturnType;    HMEncodingType returnType = HMEncodingGetType(objCReturnType);    if (returnType != HMEncodingTypeVoid &amp;&amp; returnType != HMEncodingTypeUnknown) &#123;        id returnObject = [invocation hm_getReturnValueObject];        if (returnObject) &#123;            returnValueRef = [(HMJSCExecutor *) HMCurrentExecutor convertObjectToValueRef:returnObject];        &#125;    &#125;    HMCurrentExecutor = nil;    return returnValueRef;&#125;</code></pre></div><p>继续粗暴描述：</p><ol><li>获取到 Native 侧已经注册的类名，获取到 getter 和 setter</li><li>拼装NSInvocation，处理参数，然后调用 invoke 方法执行Native 的 getter 和 setter</li><li>执行完成后，获取返回值</li><li>最后把JSValueRef返回给JSC(我理解就是 Hummer 侧)</li></ol><h3 id="3-render渲染"><a href="#3-render渲染" class="headerlink" title="3 render渲染"></a>3 render渲染</h3><p>该创建的创了，该设置的设了，然后得把它们渲染到屏幕上</p><div class="code-wrapper"><pre><code class="hljs objective-c">- (void)render:(HMBaseValue *)page &#123;    id&lt;HMBaseExecutorProtocol&gt; executor = page.context;    HMJSContext *context = [HMJSGlobal.globalObject currentContext:executor ? executor : HMCurrentExecutor];    context.didCallRender = YES;    // 里面还是用 HMJSCExecutor 将 HMBaseValue 转成具体的类，比如 UIView    NSObject *viewObject = page.toNativeObject;    if (!viewObject || ![viewObject isKindOfClass:UIView.class]) &#123;        return;    &#125;    UIView *view = (UIView *) viewObject;    [context didRenderPage:page nativeView:view];&#125;- (void)didRenderPage:(HMBaseValue *)page nativeView:(nonnull UIView *)view&#123;        self.componentView = page;    // 把这个 View 添加到屏幕上(会调用 Yoga 把节点插入到节点树上)    [self.rootView addSubview:view];    self.rootView.isHmLayoutEnabled = YES;    [self.rootView hm_markDirty];    if ([self.delegate respondsToSelector:@selector(context:didRenderPage:)]) &#123;        [self.delegate context:self didRenderPage:page];    &#125;    if (self.renderCompletion) &#123;        self.renderCompletion();    &#125;    // 排序当前视图    [UIView hm_reSortFixedView:self];    ...&#125;</code></pre></div><p>复杂地概括下：</p><ol><li>将 page 转成 Native 的 UIView 对象</li><li>渲染 UIView</li><li>把这个 UIView 添加到 rootView 上，插入到 Yoga节点树</li></ol><h3 id="4-markDirty："><a href="#4-markDirty：" class="headerlink" title="4 markDirty："></a>4 markDirty：</h3><div class="code-wrapper"><pre><code class="hljs objective-c">- (void)hm_markDirty &#123;    if (!self.isHmLayoutEnabled) &#123;        return;    &#125;    // 1. 叶节点 -&gt; 叶节点（脏），需要 markDirty + setNeedsLayout    // 2. 容器节点 -&gt; 容器节点（脏），只需要 setNeedsLayout    // 3. 叶节点 -&gt; 容器节点（脏），只需要 setNeedsLayout    // 4. 容器节点 -&gt; 叶节点（脏），只需要 setNeedsLayout    // YGAttachNodesFromViewHierachy 会针对 2 3 4 情况自行做出标记脏节点的动作    if (self.hm_renderObject.numberOfChildren == 0 &amp;&amp; self.hm_renderObject.isLeaf) &#123;        // 原先是叶节点，现在也是叶节点        [self.hm_renderObject markDirty];    &#125;    NSAssert(NSThread.isMainThread, @&quot;必须是主线程&quot;);    if (!viewSet) &#123;        viewSet = NSHashTable.weakObjectsHashTable;        dispatch_async(dispatch_get_main_queue(), ^&#123;            // 布局对应的 View（最终是通过 frame 的方式进行布局的）            [UIView hm_layoutIfNeeded];        &#125;);    &#125;    [viewSet addObject:self];&#125;</code></pre></div><h3 id="5-layout-布局"><a href="#5-layout-布局" class="headerlink" title="5 layout 布局"></a>5 layout 布局</h3><div class="code-wrapper"><pre><code class="hljs objective-c">+ (void)hm_layoutIfNeeded &#123;    if (viewSet.count == 0) &#123;        return;    &#125;    NSHashTable&lt;__kindof UIView *&gt; *rootViewSet = nil;    // viewSet 是静态变量，我猜测    NSEnumerator&lt;__kindof UIView *&gt; *enumerator = viewSet.objectEnumerator;    UIView *value = nil;    // 找到 yoga 节点树的 rootView    while ((value = enumerator.nextObject)) &#123;        UIView *rootView = hm_yoga_get_root_view(value);        if (!rootViewSet) &#123;            rootViewSet = NSHashTable.weakObjectsHashTable;        &#125;        [rootViewSet addObject:rootView];    &#125;    viewSet = nil;    enumerator = rootViewSet.objectEnumerator;    // 调用 yoga 进行布局    while ((value = enumerator.nextObject)) &#123;        [value hm_layoutYogaRootView];    &#125;&#125;// 最终会调用这个函数：// preserveOriginpreserveOrigin 为 YES，表示布局的时候继承上一次的 frame- (void)applyLayoutPreservingOrigin:(BOOL)preserveOriginpreserveOrigin dimensionFlexibility:(HummerDimensionFlexibility)dimensionFlexibility view:(UIView *)view affectedShadowViews:(NSHashTable&lt;HMRenderObject *&gt; *)affectedShadowViews &#123;    // 把 View 插入到 yoga 节点树中    [self attachRenderObjectFromViewHierarchyForRootView:view];    if (!affectedShadowViews) &#123;        affectedShadowViews = [NSHashTable weakObjectsHashTable];    &#125;    HMRenderObject *renderObject = (HMRenderObject *) view.hm_renderObject;    HMRootRenderObject *rootRenderObject = [[HMRootRenderObject alloc] init];    rootRenderObject.renderObject = renderObject;        // 最小大小直接忽略    CGSize oldMinimumSize = CGSizeMake(HMCoreGraphicsFloatFromYogaValue(YOGA_TYPE_WRAPPER(YGNodeStyleGetMinWidth)(renderObject.yogaNode), 0), HMCoreGraphicsFloatFromYogaValue(YOGA_TYPE_WRAPPER(YGNodeStyleGetMinHeight)(renderObject.yogaNode), 0));    if (!CGSizeEqualToSize(oldMinimumSize, rootRenderObject.minimumSize)) &#123;        rootRenderObject.minimumSize = oldMinimumSize;    &#125;    // 默认直接使用 rootView 大小    rootRenderObject.availableSize = view.bounds.size;    if (dimensionFlexibility &amp; HummerDimensionFlexibilityWidth) &#123;        CGSize availableSize = rootRenderObject.availableSize;        availableSize.width = CGFLOAT_MAX;        rootRenderObject.availableSize = availableSize;    &#125;    if (dimensionFlexibility &amp; HummerDimensionFlexibilityWidth) &#123;        CGSize availableSize = rootRenderObject.availableSize;        availableSize.height = CGFLOAT_MAX;        rootRenderObject.availableSize = availableSize;    &#125;    // 调用 yoga 进行布局    [rootRenderObject layoutWithAffectedShadowViews:affectedShadowViews];    if (affectedShadowViews.count &lt;= 0) &#123;        // no frame change results in no UI update block        return;    &#125;    for (HMRenderObject *shadowView in affectedShadowViews) &#123;        HMLayoutMetrics layoutMetrics = shadowView.layoutMetrics;        UIView *inlineView = shadowView.view;        hm_safe_main_thread(^&#123;            inlineView.hm_animationPropertyBounds = inlineView.bounds;            inlineView.hm_animationPropertyCenter = inlineView.center;            CGRect frame = layoutMetrics.frame;            // 只有在 HMDisplayTypeNone 或 visibility: hidden 情况下，隐藏视图            BOOL isHidden = layoutMetrics.displayType == HMDisplayTypeNone || inlineView.hm_visibility == YES;            if (inlineView.isHidden != isHidden) &#123;                inlineView.hidden = isHidden;            &#125;            if (view == inlineView) &#123;                // 需要继承上次的 origin                if (preserveOrigin) &#123;                    frame = (CGRect) &#123;                            .origin = &#123;                                    .x = (CGRectGetMinX(frame) + inlineView.frame.origin.x),                                    .y = (CGRectGetMinY(frame) + inlineView.frame.origin.y),                            &#125;,                            .size = frame.size                    &#125;;                &#125;            &#125;            // 为 shadowView 设置 frame            [inlineView hummerSetFrame:frame];        &#125;);    &#125;&#125;</code></pre></div><blockquote><p>shadowView 是什么？——辅助类，负责在 shadow 线程进行布局相关的计算</p></blockquote><p>至此，我们的 Text 组件就添加到了屏幕上，并最终显示了出来</p><p><img src="/../image/hummerRender/hierachy.png"></p><p><img src="/../image/hummerRender/result.png"></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Hummer 的渲染机制跟 ReactNative 的比较像：</p><p><img src="/../image/hummerRender/render.png"></p><p>不过还是有很多问题浮现了出来：</p><ol><li>如果组件发生了改变，Hummer 是如何刷新视图树的呢？</li><li>hummerCreate 函数是怎么一步步从 Hummer 侧调用的呢？还有 render:？（详见 <a href="https://wymann01.github.io/2022/09/05/Hummer%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/">Hummer 通信机制</a>）</li><li>Native 和 JS 是如何通信的？(<a href="https://wymann01.github.io/2022/09/05/Hummer%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/">Hummer 的通信机制</a>)</li><li>Hummer 的启动流程都做了些什么？（可以在<a href="https://wymann01.github.io/2022/09/05/Hummer%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/">这篇文章</a>里了解）</li></ol><p>这些问题我会在后续的文章中逐渐进行解答。</p><h3 id="自测习题"><a href="#自测习题" class="headerlink" title="自测习题"></a>自测习题</h3><p>根据《认知天性》，考试是最有效的学习策略之一，你能解答下面的问题吗：</p><p><strong>为什么以下写法不能生效？</strong></p><div class="code-wrapper"><pre><code class="hljs typescript">text.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;#ffffff&#x27;</span></code></pre></div><p><img src="/../image/hummerRender/doubt.png"></p><p>。</p><p>。</p><p>。</p><p>。</p><p>请诸君思考，思考</p><p>。</p><p>。</p><p>。</p><p>解答：<strong>那种写法会调用 getter 而不是 setter，也就是hm_style: 方法，而不是hm_setStyle: 方法。当然不会生效。</strong></p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>跨端框架 Hummer 通信机制 - iOS 版（滴滴内部资料）</li><li><a href="https://juejin.cn/post/6844904003692658701#heading-9" title="ReactNative 源码解析 —— 渲染机制详解">ReactNative 源码解析 —— 渲染机制详解</a></li><li><a href="https://juejin.cn/post/6844904184542822408#heading-14" title="「ReactNative 原理」 Native 层的渲染流程">「ReactNative 原理」 Native 层的渲染流程</a></li><li><a href="https://www.jianshu.com/p/7e7b462c187b" title="详解 React Native 渲染原理">详解 React Native 渲染原理</a></li><li><a href="https://hummer.didi.cn/home#/" title="Hummer">Hummer</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hummer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>performSelector 详解——从 What 到 When</title>
    <link href="/2022/05/01/performSelector%20%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E4%BB%8E%20What%20%E5%88%B0%20When/"/>
    <url>/2022/05/01/performSelector%20%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E4%BB%8E%20What%20%E5%88%B0%20When/</url>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>我最近被一位面试官问：</p><ul><li><p><code>performSelector</code> 是我们常用的方法，能不能从 <code>runloop</code> 的角度说说？</p></li><li><p><code>performSelector</code> 跟我们直接调用一个方法有什么区别？</p></li></ul><p>一下子就把我搞蒙了，转型 iOS 开发半年，编码量少，连<code>performSelector</code> 都没用过，最多在项目代码里读到，只知道大概是干嘛的，现在马上来搞懂它！</p><h2 id="performSelector-是我们常用的方法，能不能从-runloop-的角度说说？"><a href="#performSelector-是我们常用的方法，能不能从-runloop-的角度说说？" class="headerlink" title="performSelector 是我们常用的方法，能不能从 runloop 的角度说说？"></a>performSelector 是我们常用的方法，能不能从 runloop 的角度说说？</h2><blockquote><p>这个方法的入参是一个 selector，selector 属于 SEL类型，用来代表一个函数，实际上是一个 C 的 string。打印一个 selector 会得到对应方法的名字。详见<a href="https://developer.apple.com/documentation/objectivec/sel" title="官方文档">官方文档</a>。</p></blockquote><p>这里他要问的其实是<code>performSelector:withObject:afterDelay</code> 方法（Apple文档在<a href="https://developer.apple.com/documentation/objectivec/nsobject/1416176-performselector/" title="这里">这里</a>），只有这个才跟 runloop 有关系。这个方法会生成一个定时器Timer，并把它添加到当前线程的 Runloop 上，到了预定时间后 Runloop 好去执行对应的 selector （即执行方法）。</p><div class="code-wrapper"><pre><code class="hljs objective-c">+(void)performSelectorInMainThread &#123;    dispatch_async(dispatch_get_main_queue(), ^&#123;        [self performSelector:@selector(test) withObject:nil afterDelay:1.0];    &#125;);&#125;+(void)test &#123;    NSLog(@&quot;This is test method&quot;);&#125;</code></pre></div><p>注意：如果是在<strong>子线程</strong>中调用performSelector:withObject:afterDelay 方法，那就得手动获取一下 runloop，同时得让子线程中的 runloop 处于 run 状态。<strong>因为子线程中的 Runloop 不是默认创建，更不会默认 Run 起来。</strong></p><div class="code-wrapper"><pre><code class="hljs objective-c">+(void)performSelectorInOtherThread &#123;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;        NSLog(@&quot;1&quot;);        NSRunLoop *runloop = [NSRunLoop currentRunLoop]; // 注释这句,则不会执行 test 方法        [self performSelector:@selector(test) withObject:nil afterDelay:1.0];        [runloop run];// 注释这句,也不会执行 test 方法；         //同时，这句需要放在 performSelector 后面，对应的 timer 才会被添加到 Runloop 中        NSLog(@&quot;3&quot;);    &#125;);&#125;+(void)test &#123;    NSLog(@&quot;This is test method&quot;);&#125;</code></pre></div><blockquote><p>这里其实也可以引申两个问题：<br>1. 如何查看Runloop 拥有的「源」？<br>2. Runloop 在什么时候会退出？（在本示例代码中，“3”是在 Runloop退出的时候打印的，那 Runloop 怎么为啥会退出？）<br>想了解详情，请看<a href="https://juejin.cn/post/6844903781755256840" title="Runloop 与 performSelector">Runloop 与 performSelector</a></p></blockquote><h2 id="performSelector-跟我们直接调用一个方法有什么区别？"><a href="#performSelector-跟我们直接调用一个方法有什么区别？" class="headerlink" title="performSelector 跟我们直接调用一个方法有什么区别？"></a>performSelector 跟我们直接调用一个方法有什么区别？</h2><p><code>performSelector</code>是运行时决议的，用<code>performSelector</code> 可以到运行时才决定要执行哪个方法，因此编译器不会检查 <code>performSelector</code>的入参所代表的<strong>方法</strong>是否已经被 <code>caller</code> 对象实现。（因此，这时你可以在「不 import 头文件」的情况下调用方法）</p><p>而对于一般的方法调用，编译器会严格把控当前 caller 是否实现了该方法，如果没有，根本过不了编译。</p><p>这就类似于 Java 语言中的「反射」机制。</p><h2 id="performSelector-的使用"><a href="#performSelector-的使用" class="headerlink" title="performSelector 的使用"></a>performSelector 的使用</h2><p>因为对应的 selector 有可能实现，也可能没实现，所以它尝尝跟<code>respondsToSelector:</code> 搭配使用，如下代码：</p><div class="code-wrapper"><pre><code class="hljs objective-c">// 检查 self 对象是否实现了 test 方法if([self respondsToSelector:@selector(test)]) &#123;    [self performSelector:@selector(test)];&#125;</code></pre></div><p>另外，根据 Apple 的文档描述，performSelector 可能会带来内存管理问题：</p><blockquote><p>But use caution when doing this. Different messages require different memory management strategies for their returned objects, and it might not be obvious which to use.<br>Usually the caller isn’t responsible for the memory of a returned object, but that’s not true when the selector is one of the creation methods, such as <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418807-copy" title="copy">copy</a>. See <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994" title="Memory Management Policy">Memory Management Policy</a> in <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" title="Advanced Memory Management Programming Guide">Advanced Memory Management Programming Guide</a> for a description of ownership expectations. Depending on the structure of your code, it might not be clear which kind of selector you are using for any given invocation.<br>Due to this uncertainty, the compiler generates a warning if you supply a variable selector while using ARC to manage memory. Because it can’t determine ownership of the returned object at compile-time, ARC makes the assumption that the caller does <em>not</em> need to take ownership, but this may not be true. The compiler warning alerts you to the potential for a memory leak.</p></blockquote><p>大意是，如果提供的 selector 是构造方法，那么可能会带来所有权的不确定，进一步导致<strong>内存泄漏</strong>的问题。如果确定 selector 不会返回值，建议改用<a href="https://developer.apple.com/documentation/objectivec/nsobject/1414900-performselectoronmainthread" title="performSelectorOnMainThread:withObject:waitUntilDone:">performSelectorOnMainThread:withObject:waitUntilDone:</a> 。也可以改用 NSInvokation，构建一个可以返回值的 message（selector 可以被看做是一个 message，因为 Objective-C 调用方法的方式是「消息转发」）</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>动态化和组件化</p></li><li><p>多线程</p><div class="code-wrapper"><pre><code class="hljs objective-c">// 主线程- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;// 子线程- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array</code></pre></div></li><li><p>延后执行</p><div class="code-wrapper"><pre><code class="hljs objective-c">[self performSelector:@selector(test) withObject:nil afterDelay:1.0];</code></pre></div></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="https://developer.apple.com/documentation/objectivec/nsobject/1416176-performselector/" title="performSelector:withObject:afterDelay 的文档">performSelector:withObject:afterDelay 的文档</a></p></li><li><p><a href="https://juejin.cn/post/6844903781755256840" title="Runloop 与 performSelector">Runloop 与 performSelector</a>（Runloop 退出时机）</p></li><li><p><a href="https://juejin.cn/post/6844903838550327304#heading-1" title="关于 performSelector 看我就够了">关于 performSelector 看我就够了</a>（使用场景）</p></li><li><p><a href="https://developer.apple.com/documentation/objectivec/1418956-nsobject/1418867-performselector/" title="performSelector 可能导致的内存管理问题（Apple 文档）">performSelector 可能导致的内存管理问题（Apple 文档）</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
